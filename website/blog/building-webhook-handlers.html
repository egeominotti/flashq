<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Building Webhook Handlers with flashQ: Complete Tutorial - flashQ Blog</title>
  <meta name="description" content="Learn to build secure, reliable webhook handlers with flashQ. Cover signature verification, retry logic, idempotency, and processing webhooks from Stripe, GitHub, and more.">
  <meta name="keywords" content="webhook handlers, flashq webhooks, stripe webhooks, github webhooks, webhook processing, webhook queue, async webhooks, webhook security">
  <meta name="robots" content="index, follow">
  <meta name="author" content="flashQ Team">

  <meta property="og:title" content="Building Webhook Handlers with flashQ: Complete Tutorial">
  <meta property="og:description" content="Build secure, reliable webhook handlers with flashQ. Signature verification, retries, and idempotency.">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://flashq.dev/blog/building-webhook-handlers.html">
  <meta property="og:image" content="https://flashq.dev/og-image.png">
  <meta property="og:site_name" content="flashQ">
  <meta property="article:published_time" content="2026-01-19">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Building Webhook Handlers with flashQ">
  <meta name="twitter:description" content="Secure, reliable webhook handlers with flashQ.">
  <meta name="twitter:image" content="https://flashq.dev/og-image.png">

  <link rel="canonical" href="https://flashq.dev/blog/building-webhook-handlers.html">
  <link rel="alternate" type="application/rss+xml" title="flashQ Blog RSS Feed" href="https://flashq.dev/blog/feed.xml">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>âš¡</text></svg>">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "headline": "Building Webhook Handlers with flashQ: Complete Tutorial",
    "description": "Comprehensive guide to building secure webhook handlers with flashQ job queues.",
    "datePublished": "2026-01-19",
    "dateModified": "2026-01-19",
    "author": { "@type": "Organization", "name": "flashQ", "url": "https://flashq.dev" },
    "publisher": { "@type": "Organization", "name": "flashQ", "url": "https://flashq.dev" },
    "mainEntityOfPage": { "@type": "WebPage", "@id": "https://flashq.dev/blog/building-webhook-handlers.html" },
    "image": "https://flashq.dev/og-image.png"
  }
  </script>

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
      { "@type": "ListItem", "position": 1, "name": "Home", "item": "https://flashq.dev" },
      { "@type": "ListItem", "position": 2, "name": "Blog", "item": "https://flashq.dev/blog/" },
      { "@type": "ListItem", "position": 3, "name": "Building Webhook Handlers", "item": "https://flashq.dev/blog/building-webhook-handlers.html" }
    ]
  }
  </script>
</head>
<body>
  <nav>
    <div class="container wide">
      <a href="../" class="logo"><span>âš¡</span> flashQ</a>
      <div class="nav-links">
        <a href="../#features">Features</a>
        <a href="../blog/" class="active">Blog</a>
        <a href="../docs/">Docs</a>
        <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
        <a href="../docs/#quickstart" class="btn btn-primary">Get Started</a>
      </div>
      <button class="mobile-menu-btn" aria-label="Menu"><span></span><span></span><span></span></button>
    </div>
  </nav>

  <div class="mobile-menu">
    <a href="../#features">Features</a>
    <a href="../blog/">Blog</a>
    <a href="../docs/">Docs</a>
    <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
    <a href="../docs/#quickstart" class="btn btn-primary">Get Started</a>
  </div>

  <article class="blog-post">
    <div class="container narrow">
      <header class="post-header">
        <div class="post-meta">
          <span class="post-tag">Tutorial</span>
          <time datetime="2026-01-19">January 19, 2026</time>
          <span class="reading-time">12 min read</span>
        </div>
        <h1>Building Webhook Handlers with flashQ</h1>
        <p class="post-subtitle">Process webhooks reliably with job queues. Learn signature verification, idempotency, retries, and best practices for Stripe, GitHub, and custom webhooks.</p>
      </header>

      <div class="post-content">
        <nav class="toc">
          <h3>Table of Contents</h3>
          <ul>
            <li><a href="#why-queue">Why Queue Webhooks?</a></li>
            <li><a href="#architecture">Architecture Pattern</a></li>
            <li><a href="#basic-handler">Basic Webhook Handler</a></li>
            <li><a href="#signature">Signature Verification</a></li>
            <li><a href="#idempotency">Idempotency</a></li>
            <li><a href="#stripe">Stripe Webhooks</a></li>
            <li><a href="#github">GitHub Webhooks</a></li>
            <li><a href="#outgoing">Sending Webhooks</a></li>
            <li><a href="#monitoring">Monitoring</a></li>
          </ul>
        </nav>

        <h2 id="why-queue">Why Queue Webhooks?</h2>

        <p>Processing webhooks synchronously in your HTTP handler is risky:</p>

        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th>Problem</th>
                <th>Synchronous</th>
                <th>With Queue</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Slow processing blocks response</td>
                <td>Timeout, webhook fails</td>
                <td>200 OK immediately</td>
              </tr>
              <tr>
                <td>Processing fails</td>
                <td>Lost webhook</td>
                <td>Automatic retry</td>
              </tr>
              <tr>
                <td>Spike in webhooks</td>
                <td>Server overwhelmed</td>
                <td>Queue absorbs spike</td>
              </tr>
              <tr>
                <td>External service down</td>
                <td>Webhook fails</td>
                <td>Retry with backoff</td>
              </tr>
              <tr>
                <td>Duplicate webhooks</td>
                <td>Processed twice</td>
                <td>Idempotency check</td>
              </tr>
            </tbody>
          </table>
        </div>

        <h2 id="architecture">Architecture Pattern</h2>

        <pre><code class="language-text">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Webhook    â”‚     â”‚   Your API   â”‚     â”‚   flashQ     â”‚
â”‚   Provider   â”‚â”€â”€â”€â”€â–¶â”‚   Endpoint   â”‚â”€â”€â”€â”€â–¶â”‚    Queue     â”‚
â”‚ (Stripe/GH)  â”‚     â”‚              â”‚     â”‚              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                                                  â”‚
                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚    Worker    â”‚
                     â”‚  (Process)   â”‚
                     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â–¼               â–¼               â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚Database â”‚    â”‚ Email   â”‚    â”‚ Notify  â”‚
       â”‚ Update  â”‚    â”‚ Service â”‚    â”‚ Slack   â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

        <p>The key principle: <strong>Accept fast, process later</strong>. Your webhook endpoint should:</p>
        <ol>
          <li>Verify the signature</li>
          <li>Push to queue</li>
          <li>Return 200 OK</li>
        </ol>

        <h2 id="basic-handler">Basic Webhook Handler</h2>

        <pre><code class="language-typescript">// webhook-handler.ts
import express from 'express';
import { FlashQ } from 'flashq';

const app = express();
const client = new FlashQ({ host: 'localhost', port: 6789 });

// Use raw body for signature verification
app.use('/webhooks', express.raw({ type: 'application/json' }));

// Generic webhook endpoint
app.post('/webhooks/:provider', async (req, res) => {
  const { provider } = req.params;
  const rawBody = req.body.toString();
  const signature = req.headers['x-signature'] || req.headers['x-hub-signature-256'];

  try {
    // Queue the webhook for processing
    const job = await client.push(`webhook-${provider}`, {
      provider,
      payload: rawBody,
      signature,
      headers: req.headers,
      receivedAt: new Date().toISOString()
    }, {
      // Use webhook ID for idempotency
      jobId: req.headers['x-webhook-id'] || `${provider}-${Date.now()}`,
      max_attempts: 5,
      backoff: 1000
    });

    console.log(`Queued webhook ${job.id} from ${provider}`);

    // Respond immediately
    res.status(200).json({ received: true, jobId: job.id });

  } catch (error) {
    // If it's a duplicate (same jobId), that's OK
    if (error.message.includes('duplicate')) {
      res.status(200).json({ received: true, duplicate: true });
      return;
    }

    console.error('Failed to queue webhook:', error);
    res.status(500).json({ error: 'Failed to process' });
  }
});

await client.connect();
app.listen(3000, () => console.log('Webhook server running'));</code></pre>

        <h2 id="signature">Signature Verification</h2>

        <p>Always verify webhook signatures to prevent spoofing:</p>

        <pre><code class="language-typescript">// signature-utils.ts
import { createHmac, timingSafeEqual } from 'crypto';

// Generic HMAC-SHA256 verification
export function verifyHmacSignature(
  payload: string,
  signature: string,
  secret: string,
  prefix = 'sha256='
): boolean {
  const expected = prefix + createHmac('sha256', secret)
    .update(payload)
    .digest('hex');

  // Use timing-safe comparison to prevent timing attacks
  try {
    return timingSafeEqual(
      Buffer.from(signature),
      Buffer.from(expected)
    );
  } catch {
    return false;
  }
}

// Stripe-specific verification
export function verifyStripeSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const parts = signature.split(',');
  const timestamp = parts.find(p => p.startsWith('t='))?.slice(2);
  const sig = parts.find(p => p.startsWith('v1='))?.slice(3);

  if (!timestamp || !sig) return false;

  // Stripe signs: timestamp.payload
  const signedPayload = `${timestamp}.${payload}`;
  const expected = createHmac('sha256', secret)
    .update(signedPayload)
    .digest('hex');

  return timingSafeEqual(Buffer.from(sig), Buffer.from(expected));
}

// GitHub-specific verification
export function verifyGitHubSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  return verifyHmacSignature(payload, signature, secret, 'sha256=');
}</code></pre>

        <h3>Verify in Worker</h3>

        <pre><code class="language-typescript">// webhook-worker.ts
import { Worker } from 'flashq';
import { verifyStripeSignature, verifyGitHubSignature } from './signature-utils';

const worker = new Worker('webhook-stripe', async (job) => {
  const { payload, signature } = job.data;

  // Verify signature before processing
  const isValid = verifyStripeSignature(
    payload,
    signature,
    process.env.STRIPE_WEBHOOK_SECRET
  );

  if (!isValid) {
    console.error(`Invalid signature for job ${job.id}`);
    // Don't retry - this is likely a spoofed request
    return { success: false, error: 'Invalid signature' };
  }

  // Parse and process
  const event = JSON.parse(payload);
  await processStripeEvent(event);

  return { success: true, eventType: event.type };
});</code></pre>

        <h2 id="idempotency">Idempotency</h2>

        <p>Webhooks can be delivered multiple times. Make processing idempotent:</p>

        <pre><code class="language-typescript">// idempotent-processor.ts
import { Worker } from 'flashq';
import { db } from './database';

const worker = new Worker('webhook-stripe', async (job) => {
  const event = JSON.parse(job.data.payload);

  // Check if already processed
  const existing = await db.processedWebhooks.findOne({
    eventId: event.id
  });

  if (existing) {
    console.log(`Webhook ${event.id} already processed at ${existing.processedAt}`);
    return { success: true, duplicate: true };
  }

  // Process the event
  try {
    await processEvent(event);

    // Mark as processed
    await db.processedWebhooks.insert({
      eventId: event.id,
      eventType: event.type,
      processedAt: new Date()
    });

    return { success: true };

  } catch (error) {
    // If it's a constraint violation, it was processed by another worker
    if (error.code === '23505') { // PostgreSQL unique violation
      return { success: true, duplicate: true };
    }
    throw error;
  }
});

// Cleanup old records periodically
async function cleanupOldRecords() {
  const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
  await db.processedWebhooks.deleteMany({
    processedAt: { $lt: thirtyDaysAgo }
  });
}</code></pre>

        <h2 id="stripe">Stripe Webhooks Example</h2>

        <pre><code class="language-typescript">// stripe-webhook-handler.ts
import express from 'express';
import { FlashQ, Worker } from 'flashq';
import Stripe from 'stripe';

const app = express();
const client = new FlashQ({ host: 'localhost', port: 6789 });
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);

// Stripe webhook endpoint
app.post('/webhooks/stripe',
  express.raw({ type: 'application/json' }),
  async (req, res) => {
    const signature = req.headers['stripe-signature'];

    // Quick signature check before queueing
    try {
      stripe.webhooks.constructEvent(
        req.body,
        signature,
        process.env.STRIPE_WEBHOOK_SECRET
      );
    } catch (err) {
      console.error('Invalid Stripe signature:', err.message);
      return res.status(400).send('Invalid signature');
    }

    // Queue for processing
    const event = JSON.parse(req.body.toString());
    await client.push('stripe-webhooks', {
      eventId: event.id,
      eventType: event.type,
      payload: req.body.toString(),
      signature
    }, {
      jobId: event.id,  // Idempotency key
      max_attempts: 5,
      backoff: 2000
    });

    res.status(200).json({ received: true });
  }
);

// Stripe webhook worker
const stripeWorker = new Worker('stripe-webhooks', async (job) => {
  const { eventId, eventType, payload, signature } = job.data;

  // Verify signature again (defense in depth)
  const event = stripe.webhooks.constructEvent(
    payload,
    signature,
    process.env.STRIPE_WEBHOOK_SECRET
  );

  console.log(`Processing Stripe event: ${eventType}`);

  switch (event.type) {
    case 'checkout.session.completed':
      await handleCheckoutComplete(event.data.object);
      break;

    case 'invoice.paid':
      await handleInvoicePaid(event.data.object);
      break;

    case 'invoice.payment_failed':
      await handlePaymentFailed(event.data.object);
      break;

    case 'customer.subscription.updated':
      await handleSubscriptionUpdate(event.data.object);
      break;

    case 'customer.subscription.deleted':
      await handleSubscriptionCanceled(event.data.object);
      break;

    default:
      console.log(`Unhandled event type: ${event.type}`);
  }

  return { processed: eventType };
});

// Handler implementations
async function handleCheckoutComplete(session: Stripe.Checkout.Session) {
  const { customer, subscription, metadata } = session;

  await db.users.update(
    { stripeCustomerId: customer },
    {
      subscriptionId: subscription,
      subscriptionStatus: 'active',
      plan: metadata.plan
    }
  );

  await sendEmail(session.customer_email, 'Welcome!', 'welcome-template');
}

async function handlePaymentFailed(invoice: Stripe.Invoice) {
  const customer = await stripe.customers.retrieve(invoice.customer as string);

  await sendEmail(customer.email, 'Payment Failed', 'payment-failed-template', {
    amount: invoice.amount_due / 100,
    nextAttempt: invoice.next_payment_attempt
  });

  await notifySlack(`Payment failed for ${customer.email}`);
}</code></pre>

        <h2 id="github">GitHub Webhooks Example</h2>

        <pre><code class="language-typescript">// github-webhook-handler.ts
import express from 'express';
import { FlashQ, Worker } from 'flashq';
import { verifyGitHubSignature } from './signature-utils';

const app = express();
const client = new FlashQ({ host: 'localhost', port: 6789 });

// GitHub webhook endpoint
app.post('/webhooks/github',
  express.raw({ type: 'application/json' }),
  async (req, res) => {
    const signature = req.headers['x-hub-signature-256'] as string;
    const event = req.headers['x-github-event'] as string;
    const deliveryId = req.headers['x-github-delivery'] as string;

    // Verify signature
    if (!verifyGitHubSignature(
      req.body.toString(),
      signature,
      process.env.GITHUB_WEBHOOK_SECRET
    )) {
      return res.status(401).send('Invalid signature');
    }

    // Queue for processing
    await client.push('github-webhooks', {
      event,
      deliveryId,
      payload: req.body.toString()
    }, {
      jobId: deliveryId,  // Idempotency
      max_attempts: 5,
      backoff: 1000
    });

    res.status(200).send('OK');
  }
);

// GitHub webhook worker
const githubWorker = new Worker('github-webhooks', async (job) => {
  const { event, payload } = job.data;
  const data = JSON.parse(payload);

  console.log(`Processing GitHub event: ${event}`);

  switch (event) {
    case 'push':
      await handlePush(data);
      break;

    case 'pull_request':
      await handlePullRequest(data);
      break;

    case 'issues':
      await handleIssue(data);
      break;

    case 'release':
      await handleRelease(data);
      break;

    case 'workflow_run':
      await handleWorkflowRun(data);
      break;
  }

  return { processed: event };
});

async function handlePush(data: any) {
  const { repository, commits, ref } = data;

  if (ref === 'refs/heads/main') {
    // Trigger deployment
    await client.push('deploy', {
      repo: repository.full_name,
      commit: commits[0]?.id,
      branch: 'main'
    });
  }
}

async function handlePullRequest(data: any) {
  const { action, pull_request, repository } = data;

  if (action === 'opened' || action === 'synchronize') {
    // Run CI checks
    await client.push('ci-checks', {
      repo: repository.full_name,
      prNumber: pull_request.number,
      headSha: pull_request.head.sha
    });
  }

  if (action === 'closed' && pull_request.merged) {
    // Notify team
    await notifySlack(
      `PR #${pull_request.number} merged: ${pull_request.title}`
    );
  }
}

async function handleRelease(data: any) {
  const { action, release, repository } = data;

  if (action === 'published') {
    // Trigger release workflow
    await client.push('publish-release', {
      repo: repository.full_name,
      version: release.tag_name,
      releaseNotes: release.body
    });

    // Notify Discord/Slack
    await notifyDiscord(`ğŸš€ ${repository.name} ${release.tag_name} released!`);
  }
}</code></pre>

        <h2 id="outgoing">Sending Webhooks from flashQ</h2>

        <p>flashQ can also send webhooks when jobs complete:</p>

        <pre><code class="language-typescript">// Trigger webhook on job completion
await client.push('process-order', orderData, {
  webhook: {
    url: 'https://your-api.com/order-processed',
    secret: process.env.WEBHOOK_SECRET,
    events: ['completed', 'failed'],  // When to trigger
    headers: {
      'X-Custom-Header': 'value'
    }
  }
});

// Your webhook handler receives:
// {
//   "event": "completed",
//   "jobId": "123",
//   "queue": "process-order",
//   "result": { ... },
//   "completedAt": "2026-01-19T12:00:00Z"
// }

// With signature header:
// X-Webhook-Signature: sha256=abc123...</code></pre>

        <h3>Webhook Receiver</h3>

        <pre><code class="language-typescript">// Receive webhooks from flashQ
app.post('/order-processed', express.json(), async (req, res) => {
  const signature = req.headers['x-webhook-signature'];

  // Verify
  const isValid = verifyHmacSignature(
    JSON.stringify(req.body),
    signature,
    process.env.WEBHOOK_SECRET
  );

  if (!isValid) {
    return res.status(401).send('Invalid signature');
  }

  const { event, jobId, result } = req.body;

  if (event === 'completed') {
    console.log(`Order ${jobId} processed:`, result);
    // Update UI, send notification, etc.
  }

  if (event === 'failed') {
    console.error(`Order ${jobId} failed:`, result.error);
    // Alert, retry manually, etc.
  }

  res.status(200).send('OK');
});</code></pre>

        <h2 id="monitoring">Monitoring Webhooks</h2>

        <h3>Track Webhook Metrics</h3>

        <pre><code class="language-typescript">// webhook-metrics.ts
import { Worker } from 'flashq';

const metrics = {
  received: new Map<string, number>(),
  processed: new Map<string, number>(),
  failed: new Map<string, number>(),
  latency: new Map<string, number[]>()
};

const worker = new Worker('webhook-stripe', async (job) => {
  const startTime = Date.now();
  const { eventType } = job.data;

  try {
    await processEvent(job.data);

    // Track success
    metrics.processed.set(eventType,
      (metrics.processed.get(eventType) || 0) + 1
    );

    // Track latency
    const latency = Date.now() - startTime;
    const latencies = metrics.latency.get(eventType) || [];
    latencies.push(latency);
    if (latencies.length > 1000) latencies.shift();
    metrics.latency.set(eventType, latencies);

    return { success: true, latency };

  } catch (error) {
    metrics.failed.set(eventType,
      (metrics.failed.get(eventType) || 0) + 1
    );
    throw error;
  }
});

// Expose metrics endpoint
app.get('/metrics/webhooks', (req, res) => {
  const stats = {};

  for (const [event, count] of metrics.processed) {
    const failed = metrics.failed.get(event) || 0;
    const latencies = metrics.latency.get(event) || [];
    const avgLatency = latencies.length > 0
      ? latencies.reduce((a, b) => a + b, 0) / latencies.length
      : 0;

    stats[event] = {
      processed: count,
      failed,
      successRate: count / (count + failed) * 100,
      avgLatencyMs: Math.round(avgLatency)
    };
  }

  res.json(stats);
});</code></pre>

        <h3>Alerting</h3>

        <pre><code class="language-typescript">// Alert on webhook failures
const worker = new Worker('webhook-stripe', async (job) => {
  try {
    await processEvent(job.data);
  } catch (error) {
    // Alert if this is the last retry
    if (job.attempts >= 4) {  // 0-indexed, so 4 = 5th attempt
      await alertOps({
        severity: 'high',
        message: `Webhook failed after 5 attempts`,
        details: {
          jobId: job.id,
          eventType: job.data.eventType,
          error: error.message
        }
      });
    }
    throw error;
  }
});</code></pre>

        <h2>Best Practices Summary</h2>

        <div class="callout callout-info">
          <h4>Webhook Handler Checklist</h4>
          <ul>
            <li><strong>Respond fast</strong> - Return 200 within 5 seconds</li>
            <li><strong>Verify signatures</strong> - Never process unsigned webhooks</li>
            <li><strong>Use idempotency</strong> - Handle duplicate deliveries</li>
            <li><strong>Queue processing</strong> - Don't block the HTTP response</li>
            <li><strong>Retry with backoff</strong> - Handle transient failures</li>
            <li><strong>Monitor failures</strong> - Alert on repeated failures</li>
            <li><strong>Log everything</strong> - Include webhook ID for debugging</li>
          </ul>
        </div>

        <h2>Related Resources</h2>
        <ul>
          <li><a href="error-handling-retry-patterns.html">Error Handling & Retry Patterns</a></li>
          <li><a href="webhooks-event-driven.html">Webhooks & Event-Driven Architecture</a></li>
          <li><a href="security-best-practices.html">Security Best Practices</a></li>
        </ul>
      </div>

      <footer class="post-footer">
        <div class="post-tags">
          <a href="#">#webhooks</a>
          <a href="#">#stripe</a>
          <a href="#">#github</a>
          <a href="#">#tutorial</a>
        </div>
      </footer>
    </div>
  </article>

  <footer class="site-footer">
    <div class="container">
      <a href="../" class="logo"><span>âš¡</span> flashQ</a>
      <div class="footer-links">
        <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
        <a href="https://npmjs.com/package/flashq" target="_blank">npm</a>
        <a href="../docs/">Docs</a>
        <a href="../blog/">Blog</a>
      </div>
      <div class="footer-copy">Â© 2026 flashQ. MIT License.</div>
    </div>
  </footer>

  <script src="script.js"></script>
</body>
</html>
