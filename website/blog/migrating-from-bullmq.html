<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Migrating from BullMQ to flashQ: Complete Guide - flashQ Blog</title>
  <meta name="description" content="Step-by-step guide to migrate from BullMQ to flashQ. Keep your existing code, drop Redis, and get 10x better performance.">
  <meta name="keywords" content="bullmq migration, bullmq to flashq, bullmq alternative, redis-free queue, job queue migration">
  <meta name="robots" content="index, follow">

  <!-- Open Graph -->
  <meta property="og:title" content="Migrating from BullMQ to flashQ: Complete Guide">
  <meta property="og:description" content="Step-by-step guide to migrate from BullMQ to flashQ. Keep your existing code, drop Redis.">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://flashq.dev/blog/migrating-from-bullmq.html">
  <meta property="og:image" content="https://flashq.dev/og-image.png">
  <meta property="article:published_time" content="2026-01-19">

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Migrating from BullMQ to flashQ: Complete Guide">
  <meta name="twitter:description" content="Step-by-step guide to migrate from BullMQ to flashQ.">
  <meta name="twitter:image" content="https://flashq.dev/og-image.png">

  <link rel="canonical" href="https://flashq.dev/blog/migrating-from-bullmq.html">
  <link rel="alternate" type="application/rss+xml" title="flashQ Blog RSS Feed" href="https://flashq.dev/blog/feed.xml">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚ö°</text></svg>">

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="styles.css">

  <!-- Article Schema -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "Migrating from BullMQ to flashQ: Complete Guide",
    "description": "Step-by-step guide to migrate from BullMQ to flashQ.",
    "datePublished": "2026-01-19",
    "author": {
      "@type": "Organization",
      "name": "flashQ"
    }
  }
  </script>

  <!-- Breadcrumb Schema -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
      { "@type": "ListItem", "position": 1, "name": "Home", "item": "https://flashq.dev" },
      { "@type": "ListItem", "position": 2, "name": "Blog", "item": "https://flashq.dev/blog/" },
      { "@type": "ListItem", "position": 3, "name": "Migrating from BullMQ", "item": "https://flashq.dev/blog/migrating-from-bullmq.html" }
    ]
  }
  </script>
  <!-- Highlight.js -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
</head>
<body>
  <!-- Navigation -->
  <nav>
    <div class="container wide">
      <a href="../" class="logo">
        <span>‚ö°</span> flashQ
      </a>
      <div class="nav-links">
        <a href="../#features">Features</a>
        <a href="../blog/" class="active">Blog</a>
        <a href="../docs/">Docs</a>
        <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
        <button class="search-trigger" onclick="openSearch()">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>
          Search
          <span class="kbd">‚åòK</span>
        </button>
        <a href="../docs/#quickstart" class="btn btn-primary">Get Started</a>
      </div>
      <button class="mobile-menu-btn" aria-label="Menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
  </nav>

  <div class="mobile-menu">
    <a href="../#features">Features</a>
    <a href="../blog/">Blog</a>
    <a href="../docs/">Docs</a>
    <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
    <a href="../docs/#quickstart" class="btn btn-primary">Get Started</a>
  </div>

  <!-- Breadcrumb -->
  <!-- Article Header -->
  <header class="article-header header-migration">
    <div class="container">
      <span class="article-tag">Migration Guide</span>
      <h1>Migrating from BullMQ to flashQ: Complete Guide</h1>
      <div class="article-meta">
        <span>üìÖ January 19, 2026</span>
        <span class="reading-time">‚è±Ô∏è 12 min read</span>
      </div>
    </div>
  </header>

  <!-- Article Content -->
  <article class="article-content">
    <div class="container wide">
      <div class="article-layout">
        <div class="article-main">

      <p>If you're running BullMQ in production and considering a switch to flashQ, you're in the right place. This guide will walk you through the entire migration process, from updating your dependencies to handling edge cases. The good news? flashQ's API is designed to be BullMQ-compatible, making the migration straightforward.</p>

      <h2 id="why-migrate">Why Migrate from BullMQ?</h2>

      <p>Before diving into the how, let's briefly cover the why:</p>

      <table>
        <thead>
          <tr>
            <th>Aspect</th>
            <th>BullMQ + Redis</th>
            <th>flashQ</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Infrastructure</td>
            <td>Requires Redis server</td>
            <td>Single binary, no dependencies</td>
          </tr>
          <tr>
            <td>Performance</td>
            <td>~50K jobs/sec</td>
            <td>1.9M jobs/sec</td>
          </tr>
          <tr>
            <td>Latency</td>
            <td>5-10ms (network hop)</td>
            <td>&lt;1ms</td>
          </tr>
          <tr>
            <td>Payload size</td>
            <td>~512KB practical</td>
            <td>10MB</td>
          </tr>
          <tr>
            <td>Memory cost</td>
            <td>Redis RAM pricing</td>
            <td>Included in server</td>
          </tr>
        </tbody>
      </table>

      <h2 id="migration-checklist">Migration Checklist</h2>

      <p>Here's what we'll cover:</p>

      <ol>
        <li>Setting up the flashQ server</li>
        <li>Updating dependencies</li>
        <li>Updating import statements</li>
        <li>Migrating Queue instances</li>
        <li>Migrating Worker instances</li>
        <li>Handling API differences</li>
        <li>Testing the migration</li>
        <li>Production cutover strategy</li>
      </ol>

      <h2 id="step-1-server">Step 1: Set Up flashQ Server</h2>

      <p>First, you'll need the flashQ server running. Unlike Redis, flashQ is a single binary:</p>

      <pre><code class="language-bash"># Option 1: Docker (recommended)
docker run -d --name flashq -p 6789:6789 flashq/flashq

# Option 2: Download binary
curl -L https://github.com/egeominotti/flashq/releases/latest/download/flashq-linux -o flashq
chmod +x flashq
./flashq

# Option 3: With persistence (PostgreSQL)
docker run -d --name flashq \
  -p 6789:6789 \
  -e DATABASE_URL=postgres://user:pass@host/db \
  flashq/flashq</code></pre>

      <p>Verify it's running:</p>

      <pre><code class="language-bash">curl http://localhost:6790/health
# {"status":"healthy","version":"0.1.5"}</code></pre>

      <h2 id="step-2-dependencies">Step 2: Update Dependencies</h2>

      <p>Replace BullMQ with flashQ in your package.json:</p>

      <pre><code class="language-bash"># Remove BullMQ
npm uninstall bullmq

# Install flashQ
npm install flashq</code></pre>

      <p>If you were using ioredis directly for Redis connections, you can remove that too:</p>

      <pre><code class="language-bash">npm uninstall ioredis</code></pre>

      <h2 id="step-3-imports">Step 3: Update Import Statements</h2>

      <p>This is often the only code change needed. Find and replace your imports:</p>

      <pre><code class="language-typescript">// Before (BullMQ)
import { Queue, Worker, QueueEvents } from 'bullmq';

// After (flashQ)
import { Queue, Worker } from 'flashq';</code></pre>

      <p>For TypeScript projects, update your types too:</p>

      <pre><code class="language-typescript">// Before
import type { Job, JobsOptions } from 'bullmq';

// After
import type { Job, JobOptions } from 'flashq';</code></pre>

      <h2 id="step-4-queue">Step 4: Migrate Queue Instances</h2>

      <p>Queue initialization is almost identical, but connection options differ:</p>

      <pre><code class="language-typescript">// Before (BullMQ)
import { Queue } from 'bullmq';

const queue = new Queue('my-queue', {
  connection: {
    host: 'localhost',
    port: 6379,
  }
});

// After (flashQ)
import { Queue } from 'flashq';

const queue = new Queue('my-queue', {
  connection: {
    host: 'localhost',
    port: 6789,  // flashQ default port
  }
});</code></pre>

      <h3>Adding Jobs</h3>

      <p>The <code>add()</code> method is compatible:</p>

      <pre><code class="language-typescript">// Works the same in both!
await queue.add('process-order', {
  orderId: '12345',
  items: [...]
}, {
  priority: 10,
  delay: 5000,
  attempts: 3,
  backoff: {
    type: 'exponential',
    delay: 1000
  }
});</code></pre>

      <h3>Bulk Operations</h3>

      <pre><code class="language-typescript">// BullMQ
await queue.addBulk([
  { name: 'job1', data: {...} },
  { name: 'job2', data: {...} }
]);

// flashQ - same API!
await queue.addBulk([
  { name: 'job1', data: {...} },
  { name: 'job2', data: {...} }
]);</code></pre>

      <h2 id="step-5-worker">Step 5: Migrate Worker Instances</h2>

      <p>Workers are also compatible:</p>

      <pre><code class="language-typescript">// Before (BullMQ)
import { Worker } from 'bullmq';

const worker = new Worker('my-queue', async (job) => {
  console.log(`Processing ${job.id}`);
  await job.updateProgress(50);
  return { success: true };
}, {
  connection: { host: 'localhost', port: 6379 },
  concurrency: 5
});

// After (flashQ)
import { Worker } from 'flashq';

const worker = new Worker('my-queue', async (job) => {
  console.log(`Processing ${job.id}`);
  await job.updateProgress(50);
  return { success: true };
}, {
  connection: { host: 'localhost', port: 6789 },
  concurrency: 5
});</code></pre>

      <h3>Worker Events</h3>

      <p>Event handling works the same way:</p>

      <pre><code class="language-typescript">worker.on('completed', (job, result) => {
  console.log(`Job ${job.id} completed with result:`, result);
});

worker.on('failed', (job, error) => {
  console.error(`Job ${job.id} failed:`, error.message);
});

worker.on('progress', (job, progress) => {
  console.log(`Job ${job.id} progress: ${progress}%`);
});</code></pre>

      <h2 id="step-6-differences">Step 6: Handle API Differences</h2>

      <p>While most APIs are compatible, there are some differences to be aware of:</p>

      <h3>QueueEvents (Not Needed)</h3>

      <p>BullMQ uses a separate <code>QueueEvents</code> class for global events. In flashQ, events are built into the Queue class:</p>

      <pre><code class="language-typescript">// BullMQ - separate QueueEvents instance
const queueEvents = new QueueEvents('my-queue', { connection });
queueEvents.on('completed', ({ jobId, returnvalue }) => {...});

// flashQ - events on Queue instance
queue.on('completed', (job, result) => {...});</code></pre>

      <h3>Flow Producer</h3>

      <p>flashQ has a different syntax for job dependencies:</p>

      <pre><code class="language-typescript">// BullMQ FlowProducer
const flow = new FlowProducer({ connection });
await flow.add({
  name: 'parent',
  queueName: 'my-queue',
  data: {...},
  children: [
    { name: 'child1', queueName: 'my-queue', data: {...} }
  ]
});

// flashQ - use depends_on option
const child1 = await queue.add('child1', {...});
const parent = await queue.add('parent', {...}, {
  depends_on: [child1.id]
});</code></pre>

      <h3>Repeatable Jobs</h3>

      <p>flashQ uses a dedicated cron API:</p>

      <pre><code class="language-typescript">// BullMQ - repeat option
await queue.add('cleanup', {}, {
  repeat: { cron: '0 0 * * *' }
});

// flashQ - cron API
await queue.addCron('daily-cleanup', {
  queue: 'my-queue',
  schedule: '0 0 0 * * *',  // 6-field cron (includes seconds)
  data: {}
});</code></pre>

      <h3>Rate Limiting</h3>

      <p>Rate limiting is simpler in flashQ:</p>

      <pre><code class="language-typescript">// BullMQ - limiter option on worker
const worker = new Worker('my-queue', processor, {
  limiter: { max: 100, duration: 60000 }
});

// flashQ - queue-level rate limit
await queue.setRateLimit(100);  // 100 jobs per minute</code></pre>

      <h2 id="step-7-testing">Step 7: Test the Migration</h2>

      <p>Before going to production, test thoroughly:</p>

      <pre><code class="language-typescript">// test/queue.test.ts
import { Queue, Worker } from 'flashq';

describe('Queue Migration', () => {
  let queue: Queue;
  let worker: Worker;

  beforeAll(async () => {
    queue = new Queue('test-queue');
    await queue.connect();
  });

  afterAll(async () => {
    await worker?.close();
    await queue.close();
  });

  it('should process jobs', async () => {
    const results: any[] = [];

    worker = new Worker('test-queue', async (job) => {
      results.push(job.data);
      return { processed: true };
    });

    await queue.add('test', { value: 1 });
    await queue.add('test', { value: 2 });

    // Wait for processing
    await new Promise(r => setTimeout(r, 1000));

    expect(results).toHaveLength(2);
  });

  it('should handle retries', async () => {
    let attempts = 0;

    worker = new Worker('test-queue', async (job) => {
      attempts++;
      if (attempts < 3) throw new Error('Retry me');
      return { success: true };
    });

    await queue.add('retry-test', {}, { attempts: 3 });

    await new Promise(r => setTimeout(r, 3000));

    expect(attempts).toBe(3);
  });
});</code></pre>

      <h2 id="step-8-production">Step 8: Production Cutover</h2>

      <p>For a safe production migration, follow these steps:</p>

      <h3>Strategy 1: Blue-Green Deployment</h3>

      <pre><code class="language-typescript">// 1. Deploy flashQ server alongside existing Redis
// 2. Update application to use flashQ
// 3. Let existing BullMQ jobs drain
// 4. Switch traffic to new deployment
// 5. Decommission Redis when empty</code></pre>

      <h3>Strategy 2: Gradual Migration</h3>

      <p>Migrate queue by queue:</p>

      <pre><code class="language-typescript">// config/queues.ts
const USE_FLASHQ = {
  'email-queue': true,      // Migrated
  'payment-queue': false,   // Still on BullMQ
  'analytics-queue': true,  // Migrated
};

export function createQueue(name: string) {
  if (USE_FLASHQ[name]) {
    return new FlashQueue(name, { connection: flashQConfig });
  }
  return new BullMQQueue(name, { connection: redisConfig });
}</code></pre>

      <h3>Monitoring the Migration</h3>

      <pre><code class="language-typescript">// Monitor both systems during migration
const flashQStats = await flashQueue.getJobCounts();
const bullMQStats = await bullQueue.getJobCounts();

console.log('flashQ:', flashQStats);
// { waiting: 45, active: 5, completed: 1230, failed: 2 }

console.log('BullMQ:', bullMQStats);
// { waiting: 0, active: 0, completed: 5000, failed: 10 }</code></pre>

      <div class="callout callout-info">
        <div class="callout-title">üí° Pro Tip</div>
        <p>Keep your Redis instance running for a week after migration, just in case you need to rollback. Once you're confident, decommission it to start saving on infrastructure costs.</p>
      </div>

      <h2 id="common-issues">Common Issues and Solutions</h2>

      <h3>Connection Errors</h3>

      <pre><code class="language-typescript">// Ensure flashQ server is running
const queue = new Queue('my-queue', {
  connection: {
    host: process.env.FLASHQ_HOST || 'localhost',
    port: parseInt(process.env.FLASHQ_PORT || '6789'),
  }
});

// Add connection error handling
queue.on('error', (err) => {
  console.error('Queue connection error:', err);
});</code></pre>

      <h3>TypeScript Errors</h3>

      <p>If you encounter type errors, ensure you're using the correct imports:</p>

      <pre><code class="language-typescript">// Correct type imports
import type { Job, JobOptions, QueueOptions } from 'flashq';</code></pre>

      <h2 id="conclusion">Conclusion</h2>

      <p>Migrating from BullMQ to flashQ is straightforward thanks to the compatible API. The key steps are:</p>

      <ol>
        <li>Start the flashQ server</li>
        <li>Replace the npm package</li>
        <li>Update import statements</li>
        <li>Change connection port from 6379 to 6789</li>
        <li>Test thoroughly</li>
        <li>Deploy with a safe cutover strategy</li>
      </ol>

      <p>After migration, you'll benefit from:</p>

      <ul>
        <li><strong>No Redis</strong>: One less service to manage</li>
        <li><strong>10x Performance</strong>: 1.9M jobs/sec vs 50K</li>
        <li><strong>Lower Latency</strong>: Sub-millisecond response times</li>
        <li><strong>Larger Payloads</strong>: 10MB vs practical 512KB limit</li>
        <li><strong>Cost Savings</strong>: No Redis infrastructure costs</li>
      </ul>

      <!-- CTA -->
      <div class="article-cta">
        <h3>Ready to Migrate?</h3>
        <p>Get started with flashQ in 5 minutes. Your existing code will mostly just work.</p>
        <a href="../docs/#quickstart" class="btn btn-primary">Get Started ‚Üí</a>
      </div>
        </div><!-- /.article-main -->

        <!-- Table of Contents -->
        <aside class="toc-sidebar">
          <nav class="toc">
            <div class="toc-title">On this page</div>
            <ul class="toc-list">
              <li><a href="#why-migrate">Why Migrate?</a></li>
              <li><a href="#migration-checklist">Migration Checklist</a></li>
              <li><a href="#step-1-server">Step 1: Server Setup</a></li>
              <li><a href="#step-2-dependencies">Step 2: Dependencies</a></li>
              <li><a href="#step-3-imports">Step 3: Imports</a></li>
              <li><a href="#step-4-queue">Step 4: Queue Migration</a></li>
              <li><a href="#step-5-worker">Step 5: Worker Migration</a></li>
              <li><a href="#step-6-differences">Step 6: API Differences</a></li>
              <li><a href="#step-7-testing">Step 7: Testing</a></li>
              <li><a href="#step-8-production">Step 8: Production</a></li>
              <li><a href="#common-issues">Common Issues</a></li>
              <li><a href="#conclusion">Conclusion</a></li>
            </ul>
          </nav>
        </aside>
      </div><!-- /.article-layout -->
    </div>
  </article>

  <!-- Footer -->
  <footer>
    <div class="container wide">
      <a href="../" class="logo">
        <span>‚ö°</span> flashQ
      </a>
      <div class="footer-links">
        <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
        <a href="https://npmjs.com/package/flashq" target="_blank">npm</a>
        <a href="../docs/">Docs</a>
        <a href="../blog/">Blog</a>
      </div>
      <div class="footer-copy">
        ¬© <span id="year"></span> flashQ. MIT License.
      </div>
    </div>
  </footer>

  <!-- Search Modal -->
  <div class="search-overlay" id="searchOverlay" onclick="closeSearch(event)">
    <div class="search-modal" onclick="event.stopPropagation()">
      <div class="search-input-wrapper">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>
        <input type="text" class="search-modal-input" id="searchInput" placeholder="Search articles and docs..." autofocus>
        <span class="search-shortcut">ESC</span>
      </div>
      <div class="search-results" id="searchResults"></div>
      <div class="search-footer">
        <span><kbd>‚Üë</kbd><kbd>‚Üì</kbd> to navigate</span>
        <span><kbd>Enter</kbd> to select</span>
      </div>
    </div>
  </div>

  <script>
    const mobileMenuBtn = document.querySelector(".mobile-menu-btn");
    const mobileMenu = document.querySelector(".mobile-menu");
    document.getElementById("year").textContent = new Date().getFullYear();
    mobileMenuBtn.addEventListener("click", () => {
      mobileMenuBtn.classList.toggle("active");
      mobileMenu.classList.toggle("active");
      document.body.style.overflow = mobileMenu.classList.contains("active") ? "hidden" : "";
    });
    mobileMenu.querySelectorAll("a").forEach(link => {
      link.addEventListener("click", () => {
        mobileMenuBtn.classList.remove("active");
        mobileMenu.classList.remove("active");
        document.body.style.overflow = "";
      });
    });

    // TOC active state
    const tocLinks = document.querySelectorAll('.toc-list a');
    const headings = document.querySelectorAll('h2[id]');
    function updateTocActive() {
      let current = '';
      headings.forEach(heading => {
        if (window.scrollY >= heading.offsetTop - 120) {
          current = heading.getAttribute('id');
        }
      });
      tocLinks.forEach(link => {
        link.classList.toggle('active', link.getAttribute('href') === '#' + current);
      });
    }
    window.addEventListener('scroll', updateTocActive);
    updateTocActive();

    // Search
    const searchData = [
      { title: "Migrating from BullMQ", url: "migrating-from-bullmq.html", description: "Step-by-step BullMQ migration guide", tag: "Migration" },
      { title: "flashQ in Action", url: "flashq-in-action.html", description: "Interactive feature demo", tag: "Tutorial" },
      { title: "flashQ Architecture", url: "flashq-architecture.html", description: "1.9M jobs/sec design deep dive", tag: "Deep Dive" },
      { title: "Building AI Pipelines", url: "building-ai-pipelines.html", description: "RAG and LLM workflows", tag: "Tutorial" },
      { title: "Documentation", url: "../docs/", description: "Complete API reference", tag: "Docs" }
    ];
    let selectedIndex = 0;
    function openSearch() {
      document.getElementById('searchOverlay').classList.add('active');
      document.getElementById('searchInput').focus();
      document.body.style.overflow = 'hidden';
      renderResults('');
    }
    function closeSearch(e) {
      if (e && e.target !== document.getElementById('searchOverlay')) return;
      document.getElementById('searchOverlay').classList.remove('active');
      document.getElementById('searchInput').value = '';
      document.body.style.overflow = '';
    }
    function renderResults(query) {
      const results = query ? searchData.filter(item => item.title.toLowerCase().includes(query.toLowerCase()) || item.description.toLowerCase().includes(query.toLowerCase())) : searchData;
      selectedIndex = 0;
      const container = document.getElementById('searchResults');
      if (results.length === 0) { container.innerHTML = '<div class="search-empty">No results found</div>'; return; }
      container.innerHTML = results.map((item, i) => `<a href="${item.url}" class="search-result ${i === 0 ? 'active' : ''}"><div class="search-result-title">${item.title}</div><div class="search-result-description">${item.description}</div><span class="search-result-tag">${item.tag}</span></a>`).join('');
    }
    document.getElementById('searchInput').addEventListener('input', (e) => renderResults(e.target.value));
    document.addEventListener('keydown', (e) => {
      const overlay = document.getElementById('searchOverlay');
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') { e.preventDefault(); openSearch(); }
      if (e.key === 'Escape' && overlay.classList.contains('active')) closeSearch({target: overlay});
      if (overlay.classList.contains('active')) {
        const results = document.querySelectorAll('.search-result');
        if (e.key === 'ArrowDown') { e.preventDefault(); selectedIndex = Math.min(selectedIndex + 1, results.length - 1); results.forEach((r, i) => r.classList.toggle('active', i === selectedIndex)); }
        if (e.key === 'ArrowUp') { e.preventDefault(); selectedIndex = Math.max(selectedIndex - 1, 0); results.forEach((r, i) => r.classList.toggle('active', i === selectedIndex)); }
        if (e.key === 'Enter') { e.preventDefault(); results[selectedIndex]?.click(); }
      }
    });
  </script>
  <script>hljs.highlightAll();</script>
</body>
</html>
