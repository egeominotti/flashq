<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>flashQ + Next.js: Background Jobs in Vercel - flashQ Blog</title>
  <meta name="description" content="Learn how to add background jobs to your Next.js app deployed on Vercel. Process AI tasks, send emails, and handle webhooks without blocking your API routes.">
  <meta name="keywords" content="nextjs background jobs, vercel background tasks, next.js job queue, serverless background processing, nextjs flashq">
  <meta name="robots" content="index, follow">

  <meta property="og:title" content="flashQ + Next.js: Background Jobs in Vercel">
  <meta property="og:description" content="Add background jobs to your Next.js app deployed on Vercel.">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://flashq.dev/blog/nextjs-background-jobs.html">
  <meta property="og:image" content="https://flashq.dev/og-image.png">
  <meta property="article:published_time" content="2026-01-12">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="flashQ + Next.js: Background Jobs in Vercel">
  <meta name="twitter:description" content="Add background jobs to your Next.js app deployed on Vercel.">
  <meta name="twitter:image" content="https://flashq.dev/og-image.png">

  <link rel="canonical" href="https://flashq.dev/blog/nextjs-background-jobs.html">
  <link rel="alternate" type="application/rss+xml" title="flashQ Blog RSS Feed" href="https://flashq.dev/blog/feed.xml">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>âš¡</text></svg>">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="styles.css">

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "flashQ + Next.js: Background Jobs in Vercel",
    "description": "Add background jobs to your Next.js app deployed on Vercel.",
    "datePublished": "2026-01-12",
    "author": { "@type": "Organization", "name": "flashQ" }
  }
  </script>

  <!-- Breadcrumb Schema -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
      { "@type": "ListItem", "position": 1, "name": "Home", "item": "https://flashq.dev" },
      { "@type": "ListItem", "position": 2, "name": "Blog", "item": "https://flashq.dev/blog/" },
      { "@type": "ListItem", "position": 3, "name": "Next.js Background Jobs", "item": "https://flashq.dev/blog/nextjs-background-jobs.html" }
    ]
  }
  </script>
  <!-- Highlight.js -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
</head>
<body>
  <nav>
    <div class="container wide">
      <a href="../" class="logo"><span>âš¡</span> flashQ</a>
      <div class="nav-links">
        <a href="../#features">Features</a>
        <a href="../blog/" class="active">Blog</a>
        <a href="../docs/">Docs</a>
        <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
        <button class="search-trigger" onclick="openSearch()">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>
          Search <span class="kbd">âŒ˜K</span>
        </button>
        <a href="../docs/#quickstart" class="btn btn-primary">Get Started</a>
      </div>
      <button class="mobile-menu-btn" aria-label="Menu"><span></span><span></span><span></span></button>
    </div>
  </nav>

  <div class="mobile-menu">
    <a href="../#features">Features</a>
    <a href="../blog/">Blog</a>
    <a href="../docs/">Docs</a>
    <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
    <a href="../docs/#quickstart" class="btn btn-primary">Get Started</a>
  </div>

  <header class="article-header header-tutorial">
    <div class="container">
      <span class="article-tag tutorial">Tutorial</span>
      <h1>flashQ + Next.js: Background Jobs in Vercel</h1>
      <div class="article-meta">
        <span>ğŸ“… January 12, 2026</span>
        <span class="reading-time">â±ï¸ 10 min read</span>
      </div>
    </div>
  </header>

  <article class="article-content">
    <div class="container wide">
      <div class="article-layout">
        <div class="article-main">

      <p>Next.js is fantastic for building modern web applications, but it has a fundamental limitation: serverless functions have a maximum execution time (typically 10-30 seconds on Vercel). This makes it challenging to handle long-running tasks like AI processing, email sending, or webhook handling.</p>

      <p>Enter flashQ. By offloading work to a background job queue, you can keep your API routes fast while processing heavy tasks asynchronously. In this guide, we'll build a complete solution for adding background jobs to your Next.js application.</p>

      <h2 id="architecture">Architecture Overview</h2>

      <p>Here's how the pieces fit together:</p>

      <pre><code class="language-plaintext">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Next.js      â”‚     â”‚    flashQ       â”‚     â”‚    Worker       â”‚
â”‚    (Vercel)     â”‚â”€â”€â”€â”€â–¶â”‚    Server       â”‚â—€â”€â”€â”€â”€â”‚    (Railway)    â”‚
â”‚                 â”‚     â”‚    (Railway)    â”‚     â”‚                 â”‚
â”‚  - API Routes   â”‚     â”‚                 â”‚     â”‚  - AI Tasks     â”‚
â”‚  - Web App      â”‚     â”‚  - Job Queue    â”‚     â”‚  - Emails       â”‚
â”‚                 â”‚     â”‚  - Persistence  â”‚     â”‚  - Webhooks     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

      <p>The key insight: your Next.js app only <em>enqueues</em> jobs (fast), while a separate worker process <em>executes</em> them (can take as long as needed).</p>

      <h2 id="setup">Project Setup</h2>

      <h3>1. Create a Next.js App</h3>

      <pre><code class="language-bash"># Create new Next.js project
npx create-next-app@latest my-app --typescript --tailwind --app
cd my-app

# Install flashQ
npm install flashq</code></pre>

      <h3>2. Environment Variables</h3>

      <p>Create a <code>.env.local</code> file:</p>

      <pre><code class="language-bash"># flashQ server connection
FLASHQ_HOST=your-flashq-server.railway.app
FLASHQ_PORT=6789
FLASHQ_TOKEN=your-secret-token

# Or use HTTP for serverless environments
FLASHQ_HTTP_URL=https://your-flashq-server.railway.app</code></pre>

      <h3>3. Create the Queue Client</h3>

      <pre><code class="language-typescript">// lib/queue.ts
import { Queue } from 'flashq';

let queue: Queue | null = null;

export function getQueue(): Queue {
  if (!queue) {
    queue = new Queue('tasks', {
      connection: {
        host: process.env.FLASHQ_HOST!,
        port: parseInt(process.env.FLASHQ_PORT || '6789'),
        token: process.env.FLASHQ_TOKEN,
      },
      // Use HTTP mode for serverless (no persistent TCP connections)
      useHttp: true,
    });
  }
  return queue;
}</code></pre>

      <div class="callout callout-info">
        <div class="callout-title">ğŸ’¡ Why HTTP Mode?</div>
        <p>Serverless functions can't maintain persistent TCP connections. HTTP mode makes a fresh request for each operation, which works perfectly with Vercel's execution model.</p>
      </div>

      <h2 id="api-routes">Creating API Routes</h2>

      <h3>Example 1: AI Content Generation</h3>

      <pre><code class="language-typescript">// app/api/generate/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getQueue } from '@/lib/queue';

export async function POST(request: NextRequest) {
  const { prompt, userId } = await request.json();

  // Validate input
  if (!prompt || !userId) {
    return NextResponse.json(
      { error: 'Missing required fields' },
      { status: 400 }
    );
  }

  // Enqueue the job (returns immediately)
  const queue = getQueue();
  const job = await queue.add('generate-content', {
    prompt,
    userId,
    createdAt: new Date().toISOString(),
  }, {
    // Job options
    priority: 10,
    attempts: 3,
    backoff: { type: 'exponential', delay: 1000 },
  });

  // Return job ID for tracking
  return NextResponse.json({
    success: true,
    jobId: job.id,
    message: 'Content generation started',
  });
}</code></pre>

      <h3>Example 2: Check Job Status</h3>

      <pre><code class="language-typescript">// app/api/jobs/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getQueue } from '@/lib/queue';

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const queue = getQueue();

  // Get job status
  const job = await queue.getJob(params.id);

  if (!job) {
    return NextResponse.json(
      { error: 'Job not found' },
      { status: 404 }
    );
  }

  // Get progress and result
  const state = await queue.getState(params.id);
  const progress = await queue.getProgress(params.id);
  const result = state === 'completed' ? await queue.getResult(params.id) : null;

  return NextResponse.json({
    id: job.id,
    state,
    progress,
    result,
    data: job.data,
  });
}</code></pre>

      <h3>Example 3: Send Email Endpoint</h3>

      <pre><code class="language-typescript">// app/api/email/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getQueue } from '@/lib/queue';

export async function POST(request: NextRequest) {
  const { to, subject, template, data } = await request.json();

  const queue = getQueue();
  const job = await queue.add('send-email', {
    to,
    subject,
    template,
    data,
  }, {
    attempts: 5,  // Email delivery can be flaky
    backoff: { type: 'exponential', delay: 5000 },
  });

  return NextResponse.json({ queued: true, jobId: job.id });
}</code></pre>

      <h2 id="worker">Creating the Worker</h2>

      <p>The worker runs separately from your Next.js app. You can deploy it on Railway, Fly.io, or any server that supports long-running processes.</p>

      <pre><code class="language-typescript">// worker/index.ts
import { Worker } from 'flashq';
import OpenAI from 'openai';
import { Resend } from 'resend';

const openai = new OpenAI();
const resend = new Resend(process.env.RESEND_API_KEY);

// Create worker for the tasks queue
const worker = new Worker('tasks', async (job) => {
  console.log(`Processing job ${job.id}: ${job.name}`);

  switch (job.name) {
    case 'generate-content':
      return await handleContentGeneration(job);

    case 'send-email':
      return await handleSendEmail(job);

    default:
      throw new Error(`Unknown job type: ${job.name}`);
  }
}, {
  connection: {
    host: process.env.FLASHQ_HOST,
    port: parseInt(process.env.FLASHQ_PORT || '6789'),
    token: process.env.FLASHQ_TOKEN,
  },
  concurrency: 5,
});

// Handler: AI Content Generation
async function handleContentGeneration(job) {
  const { prompt, userId } = job.data;

  // Update progress
  await job.updateProgress(10, 'Starting generation...');

  // Call OpenAI
  const response = await openai.chat.completions.create({
    model: 'gpt-4',
    messages: [{ role: 'user', content: prompt }],
    max_tokens: 2000,
  });

  await job.updateProgress(90, 'Saving result...');

  // Save to database (pseudo-code)
  await db.content.create({
    userId,
    content: response.choices[0].message.content,
    jobId: job.id,
  });

  await job.updateProgress(100, 'Complete!');

  return {
    content: response.choices[0].message.content,
    tokens: response.usage?.total_tokens,
  };
}

// Handler: Send Email
async function handleSendEmail(job) {
  const { to, subject, template, data } = job.data;

  const result = await resend.emails.send({
    from: 'noreply@example.com',
    to,
    subject,
    html: renderTemplate(template, data),
  });

  return { emailId: result.id };
}

// Event handlers
worker.on('completed', (job, result) => {
  console.log(`âœ“ Job ${job.id} completed`);
});

worker.on('failed', (job, error) => {
  console.error(`âœ— Job ${job.id} failed:`, error.message);
});

console.log('Worker started, waiting for jobs...');</code></pre>

      <h2 id="frontend">Frontend Integration</h2>

      <h3>React Hook for Job Tracking</h3>

      <pre><code class="language-typescript">// hooks/useJob.ts
import { useState, useEffect } from 'react';

export function useJob(jobId: string | null) {
  const [status, setStatus] = useState&lt;{
    state: string;
    progress: number;
    result: any;
  } | null&gt;(null);

  useEffect(() => {
    if (!jobId) return;

    const pollStatus = async () => {
      const res = await fetch(`/api/jobs/${jobId}`);
      const data = await res.json();
      setStatus(data);

      // Keep polling until completed or failed
      if (data.state !== 'completed' && data.state !== 'failed') {
        setTimeout(pollStatus, 1000);
      }
    };

    pollStatus();
  }, [jobId]);

  return status;
}

// Usage in component
function GenerateButton() {
  const [jobId, setJobId] = useState&lt;string | null&gt;(null);
  const job = useJob(jobId);

  const handleGenerate = async () => {
    const res = await fetch('/api/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ prompt: 'Write a poem', userId: '123' }),
    });
    const { jobId } = await res.json();
    setJobId(jobId);
  };

  return (
    &lt;div&gt;
      &lt;button onClick={handleGenerate}&gt;Generate Content&lt;/button&gt;
      {job && (
        &lt;div&gt;
          &lt;p&gt;Status: {job.state}&lt;/p&gt;
          &lt;progress value={job.progress} max={100} /&gt;
          {job.result && &lt;pre&gt;{JSON.stringify(job.result, null, 2)}&lt;/pre&gt;}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

      <h2 id="deployment">Deployment</h2>

      <h3>Deploy flashQ Server to Railway</h3>

      <pre><code class="language-bash"># railway.toml
[build]
builder = "dockerfile"

[deploy]
startCommand = "./flashq-server"
healthcheckPath = "/health"
healthcheckTimeout = 30</code></pre>

      <pre><code class="language-bash"># Dockerfile
FROM debian:bookworm-slim
WORKDIR /app
COPY flashq-server .
RUN chmod +x flashq-server
EXPOSE 6789 6790
CMD ["./flashq-server"]</code></pre>

      <h3>Deploy Worker to Railway</h3>

      <pre><code class="language-bash"># worker/Dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build
CMD ["node", "dist/index.js"]</code></pre>

      <h3>Vercel Environment Variables</h3>

      <p>In your Vercel dashboard, add these environment variables:</p>

      <pre><code class="language-typescript">FLASHQ_HOST=your-flashq.railway.app
FLASHQ_PORT=6789
FLASHQ_TOKEN=your-secret-token</code></pre>

      <h2 id="patterns">Common Patterns</h2>

      <h3>Webhook Processing</h3>

      <pre><code class="language-typescript">// app/api/webhook/stripe/route.ts
export async function POST(request: NextRequest) {
  const event = await request.json();

  // Enqueue for processing (respond to Stripe quickly!)
  await getQueue().add('stripe-webhook', event, {
    jobId: event.id,  // Idempotency
  });

  return NextResponse.json({ received: true });
}</code></pre>

      <h3>Scheduled Tasks with Cron</h3>

      <pre><code class="language-typescript">// Set up cron jobs when worker starts
await queue.addCron('daily-report', {
  queue: 'tasks',
  schedule: '0 0 9 * * *',  // 9 AM daily
  data: { type: 'daily-report' },
});

await queue.addCron('cleanup', {
  queue: 'tasks',
  schedule: '0 0 0 * * 0',  // Weekly on Sunday
  data: { type: 'cleanup' },
});</code></pre>

      <div class="callout callout-success">
        <div class="callout-title">ğŸš€ Pro Tip</div>
        <p>Use job IDs for idempotency on webhooks. If Stripe retries a webhook, the second request will be a no-op since the job ID already exists.</p>
      </div>

      <h2 id="conclusion">Conclusion</h2>

      <p>With flashQ, you can add powerful background processing to your Next.js app without the complexity of managing Redis. The key points:</p>

      <ul>
        <li><strong>Use HTTP mode</strong> for serverless environments</li>
        <li><strong>Enqueue fast, process separately</strong> - keep API routes under timeout limits</li>
        <li><strong>Track progress</strong> with job IDs and polling</li>
        <li><strong>Deploy worker separately</strong> on Railway, Fly.io, or your own server</li>
      </ul>

      <div class="article-cta">
        <h3>Build Something Amazing</h3>
        <p>Get started with flashQ and Next.js in minutes.</p>
        <a href="../docs/#quickstart" class="btn btn-primary">Get Started â†’</a>
      </div>
        </div>

        <aside class="toc-sidebar">
          <nav class="toc">
            <div class="toc-title">On this page</div>
            <ul class="toc-list">
              <li><a href="#architecture">Architecture</a></li>
              <li><a href="#setup">Project Setup</a></li>
              <li><a href="#api-routes">API Routes</a></li>
              <li><a href="#worker">Creating the Worker</a></li>
              <li><a href="#frontend">Frontend Integration</a></li>
              <li><a href="#deployment">Deployment</a></li>
              <li><a href="#patterns">Common Patterns</a></li>
              <li><a href="#conclusion">Conclusion</a></li>
            </ul>
          </nav>
        </aside>
      </div>
    </div>
  </article>

  <footer>
    <div class="container wide">
      <a href="../" class="logo"><span>âš¡</span> flashQ</a>
      <div class="footer-links">
        <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
        <a href="https://npmjs.com/package/flashq" target="_blank">npm</a>
        <a href="../docs/">Docs</a>
        <a href="../blog/">Blog</a>
      </div>
      <div class="footer-copy">Â© <span id="year"></span> flashQ. MIT License.</div>
    </div>
  </footer>

  <div class="search-overlay" id="searchOverlay" onclick="closeSearch(event)">
    <div class="search-modal" onclick="event.stopPropagation()">
      <div class="search-input-wrapper">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>
        <input type="text" class="search-modal-input" id="searchInput" placeholder="Search articles and docs...">
        <span class="search-shortcut">ESC</span>
      </div>
      <div class="search-results" id="searchResults"></div>
    </div>
  </div>

  <script>
    document.getElementById("year").textContent = new Date().getFullYear();
    const mobileMenuBtn = document.querySelector(".mobile-menu-btn");
    const mobileMenu = document.querySelector(".mobile-menu");
    mobileMenuBtn.addEventListener("click", () => { mobileMenuBtn.classList.toggle("active"); mobileMenu.classList.toggle("active"); document.body.style.overflow = mobileMenu.classList.contains("active") ? "hidden" : ""; });
    const tocLinks = document.querySelectorAll('.toc-list a');
    const headings = document.querySelectorAll('h2[id]');
    function updateTocActive() { let current = ''; headings.forEach(h => { if (window.scrollY >= h.offsetTop - 120) current = h.id; }); tocLinks.forEach(l => l.classList.toggle('active', l.getAttribute('href') === '#' + current)); }
    window.addEventListener('scroll', updateTocActive); updateTocActive();
    const searchData = [{ title: "Next.js Background Jobs", url: "nextjs-background-jobs.html", description: "Add background jobs to Vercel", tag: "Tutorial" }, { title: "Documentation", url: "../docs/", description: "API reference", tag: "Docs" }];
    let selectedIndex = 0;
    function openSearch() { document.getElementById('searchOverlay').classList.add('active'); document.getElementById('searchInput').focus(); renderResults(''); }
    function closeSearch(e) { if (e?.target !== document.getElementById('searchOverlay')) return; document.getElementById('searchOverlay').classList.remove('active'); }
    function renderResults(q) { const r = q ? searchData.filter(i => i.title.toLowerCase().includes(q.toLowerCase())) : searchData; document.getElementById('searchResults').innerHTML = r.map((i,idx) => `<a href="${i.url}" class="search-result ${idx===0?'active':''}"><div class="search-result-title">${i.title}</div><div class="search-result-description">${i.description}</div></a>`).join('') || '<div class="search-empty">No results</div>'; }
    document.getElementById('searchInput').addEventListener('input', e => renderResults(e.target.value));
    document.addEventListener('keydown', e => { if ((e.metaKey||e.ctrlKey) && e.key==='k') { e.preventDefault(); openSearch(); } if (e.key==='Escape') closeSearch({target:document.getElementById('searchOverlay')}); });
  </script>
  <script>hljs.highlightAll();</script>
</body>
</html>
