<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Building AI Agents with flashQ and LangChain - flashQ Blog</title>
  <meta name="description" content="Build production-ready AI agents using flashQ and LangChain. Learn async tool execution, multi-agent orchestration, memory management, and scaling strategies.">
  <meta name="keywords" content="flashq langchain, ai agents, langchain tools, multi-agent systems, autonomous agents, llm orchestration, agent memory, tool execution">
  <meta name="robots" content="index, follow">
  <meta name="author" content="flashQ Team">

  <meta property="og:title" content="Building AI Agents with flashQ and LangChain">
  <meta property="og:description" content="Build production-ready AI agents with async tool execution and multi-agent orchestration.">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://flashq.dev/blog/langchain-ai-agents.html">
  <meta property="og:image" content="https://flashq.dev/og-image.png">
  <meta property="og:site_name" content="flashQ">
  <meta property="article:published_time" content="2026-01-03">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Building AI Agents with flashQ and LangChain">
  <meta name="twitter:description" content="Build production-ready AI agents with async tool execution.">
  <meta name="twitter:image" content="https://flashq.dev/og-image.png">

  <link rel="canonical" href="https://flashq.dev/blog/langchain-ai-agents.html">
  <link rel="alternate" type="application/rss+xml" title="flashQ Blog RSS Feed" href="https://flashq.dev/blog/feed.xml">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>âš¡</text></svg>">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "headline": "Building AI Agents with flashQ and LangChain",
    "description": "Build production-ready AI agents using flashQ and LangChain with async tool execution and multi-agent orchestration.",
    "datePublished": "2026-01-03",
    "author": { "@type": "Organization", "name": "flashQ" },
    "publisher": { "@type": "Organization", "name": "flashQ", "logo": { "@type": "ImageObject", "url": "https://flashq.dev/logo.png" } }
  }
  </script>

  <!-- Breadcrumb Schema -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
      { "@type": "ListItem", "position": 1, "name": "Home", "item": "https://flashq.dev" },
      { "@type": "ListItem", "position": 2, "name": "Blog", "item": "https://flashq.dev/blog/" },
      { "@type": "ListItem", "position": 3, "name": "LangChain AI Agents", "item": "https://flashq.dev/blog/langchain-ai-agents.html" }
    ]
  }
  </script>
  <!-- Highlight.js -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
</head>
<body>
  <nav>
    <div class="container wide">
      <a href="../" class="logo"><span>âš¡</span> flashQ</a>
      <div class="nav-links">
        <a href="../#features">Features</a>
        <a href="../blog/" class="active">Blog</a>
        <a href="../docs/">Docs</a>
        <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
        <button class="search-trigger" onclick="openSearch()"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>Search <span class="kbd">âŒ˜K</span></button>
        <a href="../docs/#quickstart" class="btn btn-primary">Get Started</a>
      </div>
      <button class="mobile-menu-btn" aria-label="Menu"><span></span><span></span><span></span></button>
    </div>
  </nav>

  <div class="mobile-menu">
    <a href="../#features">Features</a><a href="../blog/">Blog</a><a href="../docs/">Docs</a>
    <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
    <a href="../docs/#quickstart" class="btn btn-primary">Get Started</a>
  </div>

  <header class="article-header header-ai">
    <div class="container">
      <span class="article-tag">AI/ML</span>
      <h1>Building AI Agents with flashQ and LangChain</h1>
      <div class="article-meta">
        <span>ğŸ“… January 3, 2026</span>
        <span class="reading-time">â±ï¸ 16 min read</span>
      </div>
    </div>
  </header>

  <article class="article-content">
    <div class="container wide">
      <div class="article-layout">
        <div class="article-main">

      <p>AI agents are autonomous systems that can plan, reason, and execute complex tasks. When combined with LangChain's agent framework and flashQ's reliable job processing, you can build production-ready agents that scale. This guide covers everything from basic tool execution to multi-agent orchestration.</p>

      <h2 id="what-are-agents">What Are AI Agents?</h2>

      <p>Unlike simple chatbots, AI agents can:</p>

      <ul>
        <li><strong>Plan</strong>: Break down complex tasks into steps</li>
        <li><strong>Execute</strong>: Use tools to accomplish subtasks</li>
        <li><strong>React</strong>: Adapt based on tool results</li>
        <li><strong>Remember</strong>: Maintain context across interactions</li>
      </ul>

      <div class="callout callout-info">
        <div class="callout-title">Why flashQ for Agents?</div>
        <p>AI agents often execute long-running tasks (web searches, API calls, computations). flashQ ensures reliable execution with retries, timeouts, and progress tracking.</p>
      </div>

      <h2 id="architecture">Agent Architecture</h2>

      <pre><code class="language-typescript">// Architecture Overview
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    User Request                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Agent Controller                       â”‚
â”‚  â€¢ Parse intent                                          â”‚
â”‚  â€¢ Create execution plan                                 â”‚
â”‚  â€¢ Coordinate tools                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â–¼               â–¼               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Search    â”‚  â”‚  Code      â”‚  â”‚  Database  â”‚
    â”‚  Tool      â”‚  â”‚  Executor  â”‚  â”‚  Tool      â”‚
    â”‚  (Queue)   â”‚  â”‚  (Queue)   â”‚  â”‚  (Queue)   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚               â”‚               â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   flashQ Workers                         â”‚
â”‚  â€¢ Execute tools async                                   â”‚
â”‚  â€¢ Handle retries                                        â”‚
â”‚  â€¢ Track progress                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

      <h2 id="setup">Project Setup</h2>

      <pre><code class="language-bash"># Install dependencies
npm install flashq langchain @langchain/openai @langchain/community zod</code></pre>

      <pre><code class="language-typescript">// agent-config.ts
import { FlashQ, Worker } from 'flashq';
import { ChatOpenAI } from '@langchain/openai';

export const flashq = new FlashQ({
  host: process.env.FLASHQ_HOST || 'localhost',
  port: 6789,
  token: process.env.FLASHQ_TOKEN
});

export const llm = new ChatOpenAI({
  modelName: 'gpt-4-turbo',
  temperature: 0,
  openAIApiKey: process.env.OPENAI_API_KEY
});

// Tool queue names
export const QUEUES = {
  AGENT_TASKS: 'agent:tasks',
  TOOL_SEARCH: 'tool:search',
  TOOL_CODE: 'tool:code',
  TOOL_DATABASE: 'tool:database',
  TOOL_EMAIL: 'tool:email'
};</code></pre>

      <h2 id="langchain-tools">Creating LangChain Tools with flashQ</h2>

      <h3>Define Async Tools</h3>

      <pre><code class="language-typescript">// tools/search-tool.ts
import { DynamicStructuredTool } from 'langchain/tools';
import { z } from 'zod';
import { flashq, QUEUES } from '../agent-config';

export const searchTool = new DynamicStructuredTool({
  name: 'web_search',
  description: 'Search the web for current information. Use for questions about recent events, facts, or research.',
  schema: z.object({
    query: z.string().describe('The search query'),
    maxResults: z.number().default(5).describe('Maximum results to return')
  }),
  func: async ({ query, maxResults }) => {
    // Push to flashQ for async execution
    const job = await flashq.push(QUEUES.TOOL_SEARCH, {
      query,
      maxResults,
      timestamp: Date.now()
    }, {
      timeout: 30000,
      max_attempts: 3
    });

    // Wait for result (blocks until complete)
    const result = await flashq.finished(job.id, 60000);

    return JSON.stringify(result.data);
  }
});

// tools/code-executor.ts
export const codeExecutorTool = new DynamicStructuredTool({
  name: 'execute_code',
  description: 'Execute Python code in a sandboxed environment. Use for calculations, data analysis, or code testing.',
  schema: z.object({
    code: z.string().describe('Python code to execute'),
    timeout: z.number().default(30).describe('Execution timeout in seconds')
  }),
  func: async ({ code, timeout }) => {
    const job = await flashq.push(QUEUES.TOOL_CODE, {
      code,
      language: 'python',
      sandboxed: <span class="literal">true
    }, {
      timeout: timeout * 1000,
      max_attempts: 1 // No retry for code execution
    });

    const result = await flashq.finished(job.id);

    if (result.error) {
      return `Error: ${result.error}`;
    }
    return result.output;
  }
});

// tools/database-tool.ts
export const databaseTool = new DynamicStructuredTool({
  name: 'query_database',
  description: 'Query the database. Use for retrieving user data, analytics, or stored information.',
  schema: z.object({
    sql: z.string().describe('SQL query (SELECT only)'),
    params: z.array(z.any()).default([]).describe('Query parameters')
  }),
  func: async ({ sql, params }) => {
    // Validate: only SELECT allowed
    if (!sql.trim().toLowerCase().startsWith('select')) {
      return 'Error: Only SELECT queries are allowed';
    }

    const job = await flashq.push(QUEUES.TOOL_DATABASE, {
      sql,
      params,
      readOnly: <span class="literal">true
    }, {
      timeout: 10000
    });

    const result = await flashq.finished(job.id);
    return JSON.stringify(result.rows, <span class="literal">null, 2);
  }
});</code></pre>

      <h3>Tool Workers</h3>

      <pre><code class="language-typescript">// workers/search-worker.ts
import { Worker } from 'flashq';
import { flashq, QUEUES } from '../agent-config';

const searchWorker = new Worker(flashq, QUEUES.TOOL_SEARCH, async (job) => {
  const { query, maxResults } = job.data;

  // Use your preferred search API
  const response = await fetch(
    `https://api.search.io/search?q=${encodeURIComponent(query)}&limit=${maxResults}`,
    { headers: { 'Authorization': `Bearer ${process.env.SEARCH_API_KEY}` } }
  );

  const data = await response.json();

  return {
    query,
    results: data.results.map((r: any) => ({
      title: r.title,
      url: r.url,
      snippet: r.snippet
    }))
  };
}, { concurrency: 10 });

// workers/code-worker.ts
import { spawn } from 'child_process';

const codeWorker = new Worker(flashq, QUEUES.TOOL_CODE, async (job) => {
  const { code, timeout = 30 } = job.data;

  return new Promise((resolve, reject) => {
    const process = spawn('python3', ['-c', code], {
      timeout: timeout * 1000
    });

    let output = '';
    let error = '';

    process.stdout.on('data', (data) => output += data);
    process.stderr.on('data', (data) => error += data);

    process.on('close', (code) => {
      if (code === 0) {
        resolve({ output: output.trim() });
      } else {
        resolve({ error: error.trim() || 'Execution failed' });
      }
    });
  });
}, { concurrency: 5 });</code></pre>

      <h2 id="react-agent">ReAct Agent Pattern</h2>

      <p>The ReAct (Reasoning + Acting) pattern combines chain-of-thought reasoning with tool execution.</p>

      <pre><code class="language-typescript">// agents/react-agent.ts
import { AgentExecutor, createReactAgent } from 'langchain/agents';
import { pull } from 'langchain/hub';
import { llm, flashq, QUEUES } from '../agent-config';
import { searchTool, codeExecutorTool, databaseTool } from '../tools';

async function createAgent() {
  // Pull ReAct prompt from LangChain hub
  const prompt = await pull('hwchase17/react');

  const tools = [
    searchTool,
    codeExecutorTool,
    databaseTool
  ];

  const agent = await createReactAgent({
    llm,
    tools,
    prompt
  });

  return new AgentExecutor({
    agent,
    tools,
    verbose: <span class="literal">true,
    maxIterations: 10,
    returnIntermediateSteps: <span class="literal">true
  });
}

// Run agent as a flashQ job
const agentWorker = new Worker(flashq, QUEUES.AGENT_TASKS, async (job) => {
  const { task, context } = job.data;

  const executor = await createAgent();

  // Update progress as agent thinks
  await flashq.progress(job.id, 10, 'Agent initialized');

  const result = await executor.invoke({
    input: task,
    chat_history: context?.history || []
  }, {
    callbacks: [{
      handleAgentAction: async (action) => {
        await flashq.progress(
          job.id,
          50,
          `Using tool: ${action.tool}`
        );
      }
    }]
  });

  await flashq.progress(job.id, 100, 'Complete');

  return {
    output: result.output,
    steps: result.intermediateSteps?.map(s => ({
      tool: s.action.tool,
      input: s.action.toolInput,
      output: s.observation
    }))
  };
}, { concurrency: 3 });</code></pre>

      <h2 id="multi-agent">Multi-Agent Orchestration</h2>

      <p>For complex tasks, multiple specialized agents can work together.</p>

      <pre><code class="language-typescript">// agents/multi-agent-system.ts
import { flashq, llm, QUEUES } from '../agent-config';

interface AgentConfig {
  name: string;
  role: string;
  tools: string[];
  systemPrompt: string;
}

const AGENTS: AgentConfig[] = [
  {
    name: 'researcher',
    role: 'Research and gather information',
    tools: ['web_search', 'query_database'],
    systemPrompt: `You are a research specialist. Your job is to find accurate,
                   relevant information. Always cite your sources.`
  },
  {
    name: 'analyst',
    role: 'Analyze data and draw conclusions',
    tools: ['execute_code', 'query_database'],
    systemPrompt: `You are a data analyst. Analyze the provided data and extract
                   meaningful insights. Use code for complex calculations.`
  },
  {
    name: 'writer',
    role: 'Create polished content',
    tools: [],
    systemPrompt: `You are a technical writer. Transform research and analysis
                   into clear, engaging content.`
  }
];

// Orchestrator coordinates multiple agents
async function orchestrateAgents(task: string): Promise&lt;string&gt; {
  // Step 1: Research phase
  const researchJob = await flashq.push('agent:researcher', {
    task: `Research the following topic: ${task}`,
    agent: AGENTS[0]
  });

  const research = await flashq.finished(researchJob.id, 120000);

  // Step 2: Analysis phase (depends on research)
  const analysisJob = await flashq.push('agent:analyst', {
    task: `Analyze this research: ${JSON.stringify(research.data)}`,
    agent: AGENTS[1],
    context: { research: research.data }
  }, {
    depends_on: [researchJob.id]
  });

  const analysis = await flashq.finished(analysisJob.id, 120000);

  // Step 3: Writing phase (depends on both)
  const writeJob = await flashq.push('agent:writer', {
    task: `Write a report based on: ${JSON.stringify(analysis.data)}`,
    agent: AGENTS[2],
    context: { research: research.data, analysis: analysis.data }
  });

  const report = await flashq.finished(writeJob.id, 60000);

  return report.data.content;
}

// Using flashQ flows for parallel agents
async function parallelAgents(tasks: string[]) {
  const flow = {
    name: 'parallel-research',
    children: tasks.map((task, i) => ({
      name: `research-${i}`,
      data: { task, agent: AGENTS[0] }
    }))
  };

  const result = await flashq.pushFlow('agent:researcher', flow);

  // Wait for all parallel tasks
  const results = await Promise.all(
    result.children.map(child => flashq.finished(child.id))
  );

  return results.map(r => r.data);
}</code></pre>

      <h2 id="memory">Agent Memory Management</h2>

      <pre><code class="language-typescript">// memory/agent-memory.ts
import { BufferMemory, ConversationSummaryMemory } from 'langchain/memory';
import { flashq, llm } from '../agent-config';

interface MemoryEntry {
  sessionId: string;
  messages: any[];
  summary: string;
  updatedAt: number;
}

// Memory persisted via flashQ
class PersistentAgentMemory {
  private sessionId: string;
  private memory: BufferMemory;

  constructor(sessionId: string) {
    this.sessionId = sessionId;
    this.memory = new BufferMemory({
      returnMessages: <span class="literal">true,
      memoryKey: 'chat_history'
    });
  }

  async load(): Promise&lt;void&gt; {
    // Load from flashQ result storage
    const stored = await flashq.getResult(`memory:${this.sessionId}`);

    if (stored) {
      for (const msg of stored.messages) {
        await this.memory.saveContext(
          { input: msg.human },
          { output: msg.ai }
        );
      }
    }
  }

  async save(human: string, ai: string): Promise&lt;void&gt; {
    await this.memory.saveContext({ input: human }, { output: ai });

    // Persist to flashQ
    const history = await this.memory.loadMemoryVariables({});

    await flashq.push('memory:save', {
      sessionId: this.sessionId,
      messages: history.chat_history,
      updatedAt: Date.now()
    }, {
      jobId: `memory:${this.sessionId}`
    });
  }

  async getHistory() {
    return this.memory.loadMemoryVariables({});
  }
}

// Agent with memory
async function agentWithMemory(sessionId: string, input: string) {
  const memory = new PersistentAgentMemory(sessionId);
  await memory.load();

  const history = await memory.getHistory();

  // Run agent with history context
  const job = await flashq.push(QUEUES.AGENT_TASKS, {
    task: input,
    context: { history: history.chat_history }
  });

  const result = await flashq.finished(job.id);

  // Save interaction to memory
  await memory.save(input, result.data.output);

  return result.data.output;
}</code></pre>

      <h2 id="streaming">Streaming Agent Responses</h2>

      <pre><code class="language-typescript">// streaming/agent-stream.ts
import { flashq, llm } from '../agent-config';

// Server-side: Stream agent thoughts via WebSocket
async function streamAgentExecution(ws: WebSocket, taskId: string) {
  const eventSource = new EventSource(
    `http://localhost:6790/events/${taskId}`
  );

  eventSource.onmessage = (event) => {
    const data = JSON.parse(event.data);

    switch (data.event) {
      case 'progress':
        ws.send(JSON.stringify({
          type: 'thinking',
          message: data.message,
          progress: data.progress
        }));
        break;

      case 'completed':
        ws.send(JSON.stringify({
          type: 'complete',
          result: data.result
        }));
        eventSource.close();
        break;
    }
  };
}

// Client-side: React component for streaming
function AgentChat() {
  const [messages, setMessages] = useState([]);
  const [thinking, setThinking] = useState(<span class="literal">null);

  async function sendMessage(input: string) {
    // Start agent task
    const response = await fetch('/api/agent', {
      method: 'POST',
      body: JSON.stringify({ input })
    });

    const { taskId } = await response.json();

    // Connect to WebSocket for updates
    const ws = new WebSocket(`ws://localhost:6790/ws?token=xxx`);

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);

      if (data.type === 'thinking') {
        setThinking(data.message);
      } else if (data.type === 'complete') {
        setThinking(<span class="literal">null);
        setMessages(prev => [...prev, {
          role: 'assistant',
          content: data.result
        }]);
        ws.close();
      }
    };
  }

  return (
    &lt;div&gt;
      {messages.map((msg, i) => &lt;Message key={i} {...msg} /&gt;)}
      {thinking && &lt;ThinkingIndicator message={thinking} /&gt;}
    &lt;/div&gt;
  );
}</code></pre>

      <h2 id="error-handling">Error Handling & Recovery</h2>

      <pre><code class="language-typescript">// error-handling/agent-recovery.ts
import { flashq, QUEUES } from '../agent-config';

// Wrap agent execution with recovery
async function resilientAgentExecution(task: string) {
  const job = await flashq.push(QUEUES.AGENT_TASKS, {
    task,
    startedAt: Date.now()
  }, {
    max_attempts: 3,
    backoff: 5000,
    timeout: 300000, // 5 min timeout

    // Custom error handling
    onFailed: async (error) => {
      console.error(`Agent task failed: ${error}`);

      // Push to DLQ for manual review
      await flashq.push('agent:failed', {
        originalTask: task,
        error: error.message,
        timestamp: Date.now()
      });
    }
  });

  try {
    return await flashq.finished(job.id, 300000);
  } catch (error) {
    // Timeout or failure - check job state
    const state = await flashq.getState(job.id);

    if (state === 'failed') {
      const dlqJobs = await flashq.getDlq(QUEUES.AGENT_TASKS);
      const failedJob = dlqJobs.find(j => j.id === job.id);

      return {
        success: <span class="literal">false,
        error: failedJob?.error || 'Unknown error',
        attempts: failedJob?.attempts
      };
    }

    throw error;
  }
}

// Tool-level error handling
const robustSearchTool = new DynamicStructuredTool({
  name: 'robust_search',
  description: 'Search with automatic fallback',
  schema: z.object({ query: z.string() }),
  func: async ({ query }) => {
    const providers = ['google', 'bing', 'duckduckgo'];

    for (const provider of providers) {
      try {
        const job = await flashq.push(QUEUES.TOOL_SEARCH, {
          query,
          provider
        }, { timeout: 15000, max_attempts: 1 });

        const result = await flashq.finished(job.id, 20000);
        return JSON.stringify(result.data);
      } catch (error) {
        console.warn(`${provider} failed, trying next...`);
      }
    }

    return 'Search temporarily unavailable';
  }
});</code></pre>

      <h2 id="monitoring">Monitoring & Observability</h2>

      <pre><code class="language-typescript">// monitoring/agent-metrics.ts
import { flashq } from '../agent-config';

// Dashboard metrics
async function getAgentMetrics() {
  const metrics = await flashq.metrics();

  const agentQueues = Object.entries(metrics.queues)
    .filter(([name]) => name.startsWith('agent:') || name.startsWith('tool:'));

  return {
    totalAgentTasks: agentQueues.reduce((sum, [, q]) =>
      sum + q.completed + q.active + q.waiting, 0),

    activeAgents: agentQueues
      .filter(([, q]) => q.active > 0)
      .map(([name, q]) => ({ name, active: q.active })),

    toolUsage: agentQueues
      .filter(([name]) => name.startsWith('tool:'))
      .map(([name, q]) => ({
        tool: name.replace('tool:', ''),
        completed: q.completed,
        failed: q.failed,
        avgLatency: q.avgProcessingTime
      })),

    errorRate: agentQueues.reduce((sum, [, q]) => sum + q.failed, 0) /
               agentQueues.reduce((sum, [, q]) => sum + q.completed + q.failed, 1)
  };
}

// Prometheus metrics endpoint
app.get('/metrics/agents', async (req, res) => {
  const metrics = await getAgentMetrics();

  const prometheus = `
# HELP agent_tasks_total Total agent tasks
# TYPE agent_tasks_total counter
agent_tasks_total ${metrics.totalAgentTasks}

# HELP agent_error_rate Agent error rate
# TYPE agent_error_rate gauge
agent_error_rate ${metrics.errorRate}

${metrics.toolUsage.map(t => `
# HELP tool_${t.tool}_completed Tool executions
# TYPE tool_${t.tool}_completed counter
tool_${t.tool}_completed ${t.completed}
tool_${t.tool}_latency_ms ${t.avgLatency}`).join('\n')}
`;

  res.set('Content-Type', 'text/plain');
  res.send(prometheus);
});</code></pre>

      <div class="callout callout-success">
        <div class="callout-title">Production Checklist</div>
        <p>âœ“ Rate limit LLM API calls<br>âœ“ Set appropriate timeouts for each tool<br>âœ“ Implement graceful degradation<br>âœ“ Monitor token usage and costs<br>âœ“ Log all agent decisions<br>âœ“ Test tool error scenarios</p>
      </div>

      <h2 id="conclusion">Conclusion</h2>

      <p>Combining flashQ with LangChain gives you a robust foundation for production AI agents. The key benefits are reliable tool execution, automatic retries, progress tracking, and scalable worker pools for parallel agent operations.</p>

      <div class="article-cta">
        <h3>Build AI Agents Today</h3>
        <p>Start building production-ready AI agents with flashQ and LangChain.</p>
        <a href="../docs/#quickstart" class="btn btn-primary">Get Started â†’</a>
      </div>
        </div>

        <aside class="toc-sidebar">
          <nav class="toc">
            <div class="toc-title">On this page</div>
            <ul class="toc-list">
              <li><a href="#what-are-agents">What Are AI Agents?</a></li>
              <li><a href="#architecture">Architecture</a></li>
              <li><a href="#setup">Project Setup</a></li>
              <li><a href="#langchain-tools">LangChain Tools</a></li>
              <li><a href="#react-agent">ReAct Agent</a></li>
              <li><a href="#multi-agent">Multi-Agent</a></li>
              <li><a href="#memory">Memory Management</a></li>
              <li><a href="#streaming">Streaming</a></li>
              <li><a href="#error-handling">Error Handling</a></li>
              <li><a href="#monitoring">Monitoring</a></li>
              <li><a href="#conclusion">Conclusion</a></li>
            </ul>
          </nav>
        </aside>
      </div>
    </div>
  </article>

  <footer>
    <div class="container wide">
      <a href="../" class="logo"><span>âš¡</span> flashQ</a>
      <div class="footer-links">
        <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
        <a href="https://npmjs.com/package/flashq" target="_blank">npm</a>
        <a href="../docs/">Docs</a>
        <a href="../blog/">Blog</a>
      </div>
      <div class="footer-copy">Â© <span id="year"></span> flashQ. MIT License.</div>
    </div>
  </footer>

  <div class="search-overlay" id="searchOverlay" onclick="closeSearch(event)">
    <div class="search-modal" onclick="event.stopPropagation()">
      <div class="search-input-wrapper">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>
        <input type="text" class="search-modal-input" id="searchInput" placeholder="Search...">
        <span class="search-shortcut">ESC</span>
      </div>
      <div class="search-results" id="searchResults"></div>
    </div>
  </div>

  <script>
    document.getElementById("year").textContent = new Date().getFullYear();
    const mobileMenuBtn = document.querySelector(".mobile-menu-btn");
    const mobileMenu = document.querySelector(".mobile-menu");
    mobileMenuBtn.addEventListener("click", () => { mobileMenuBtn.classList.toggle("active"); mobileMenu.classList.toggle("active"); });
    const tocLinks = document.querySelectorAll('.toc-list a');
    const headings = document.querySelectorAll('h2[id]');
    function updateTocActive() { let current = ''; headings.forEach(h => { if (window.scrollY >= h.offsetTop - 120) current = h.id; }); tocLinks.forEach(l => l.classList.toggle('active', l.getAttribute('href') === '#' + current)); }
    window.addEventListener('scroll', updateTocActive); updateTocActive();
    function openSearch() { document.getElementById('searchOverlay').classList.add('active'); document.getElementById('searchInput').focus(); }
    function closeSearch(e) { if (e?.target === document.getElementById('searchOverlay')) document.getElementById('searchOverlay').classList.remove('active'); }
    document.addEventListener('keydown', e => { if ((e.metaKey||e.ctrlKey) && e.key==='k') { e.preventDefault(); openSearch(); } if (e.key==='Escape') closeSearch({target:document.getElementById('searchOverlay')}); });
  </script>
  <script>hljs.highlightAll();</script>
</body>
</html>
