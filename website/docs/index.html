<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Documentation - flashQ</title>
  <meta name="description" content="Complete documentation for flashQ - the high-performance job queue for AI workloads.">

  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚ö°</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg: #0a0a0b;
      --bg-secondary: #111113;
      --bg-tertiary: #18181b;
      --border: #27272a;
      --text: #fafafa;
      --text-secondary: #a1a1aa;
      --text-muted: #71717a;
      --accent: #f97316;
      --accent-hover: #fb923c;
      --green: #22c55e;
      --blue: #3b82f6;
      --purple: #a855f7;
      --yellow: #eab308;
      --sidebar-width: 280px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.7;
      -webkit-font-smoothing: antialiased;
    }

    /* Layout */
    .docs-layout {
      display: flex;
      min-height: 100vh;
    }

    /* Sidebar */
    .sidebar {
      width: var(--sidebar-width);
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      overflow-y: auto;
      padding: 24px 0;
    }

    .sidebar-header {
      padding: 0 24px 24px;
      border-bottom: 1px solid var(--border);
      margin-bottom: 24px;
    }

    .sidebar-logo {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 700;
      font-size: 1.25rem;
      color: var(--text);
      text-decoration: none;
    }

    .sidebar-logo span {
      font-size: 1.5rem;
    }

    .sidebar-version {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 4px;
    }

    .sidebar-section {
      margin-bottom: 24px;
    }

    .sidebar-section-title {
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      padding: 0 24px;
      margin-bottom: 8px;
    }

    .sidebar-nav {
      list-style: none;
    }

    .sidebar-nav a {
      display: block;
      padding: 8px 24px;
      color: var(--text-secondary);
      text-decoration: none;
      font-size: 0.875rem;
      transition: all 0.15s;
      border-left: 2px solid transparent;
    }

    .sidebar-nav a:hover {
      color: var(--text);
      background: var(--bg-tertiary);
    }

    .sidebar-nav a.active {
      color: var(--accent);
      border-left-color: var(--accent);
      background: rgba(249, 115, 22, 0.1);
    }

    .sidebar-nav .nested {
      padding-left: 16px;
    }

    .sidebar-nav .nested a {
      font-size: 0.813rem;
      padding: 6px 24px 6px 40px;
    }

    /* Main content */
    .main-content {
      flex: 1;
      margin-left: var(--sidebar-width);
      max-width: 900px;
      padding: 48px 64px;
    }

    /* Typography */
    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 16px;
      letter-spacing: -0.02em;
    }

    h2 {
      font-size: 1.75rem;
      font-weight: 600;
      margin-top: 48px;
      margin-bottom: 16px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }

    h3 {
      font-size: 1.25rem;
      font-weight: 600;
      margin-top: 32px;
      margin-bottom: 12px;
    }

    h4 {
      font-size: 1rem;
      font-weight: 600;
      margin-top: 24px;
      margin-bottom: 8px;
    }

    p {
      margin-bottom: 16px;
      color: var(--text-secondary);
    }

    .lead {
      font-size: 1.125rem;
      color: var(--text-secondary);
      margin-bottom: 32px;
    }

    a {
      color: var(--accent);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    /* Code */
    code {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.875em;
      background: var(--bg-tertiary);
      padding: 2px 6px;
      border-radius: 4px;
      color: var(--accent);
    }

    pre {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 20px;
      overflow-x: auto;
      margin: 16px 0 24px;
    }

    pre code {
      background: none;
      padding: 0;
      color: var(--text);
      font-size: 0.875rem;
      line-height: 1.6;
    }

    .code-block {
      position: relative;
    }

    .code-block-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-bottom: none;
      border-radius: 8px 8px 0 0;
      padding: 8px 16px;
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .code-block-header + pre {
      margin-top: 0;
      border-radius: 0 0 8px 8px;
    }

    .copy-btn {
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text-secondary);
      padding: 4px 12px;
      border-radius: 4px;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.15s;
    }

    .copy-btn:hover {
      background: var(--border);
      color: var(--text);
    }

    /* Syntax highlighting */
    .token-keyword { color: #c084fc; }
    .token-string { color: #4ade80; }
    .token-comment { color: #6b7280; }
    .token-function { color: #60a5fa; }
    .token-variable { color: #fbbf24; }
    .token-number { color: #f472b6; }
    .token-operator { color: #94a3b8; }

    /* Tables */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 16px 0 24px;
      font-size: 0.875rem;
    }

    th, td {
      text-align: left;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
    }

    th {
      background: var(--bg-secondary);
      font-weight: 600;
      color: var(--text);
    }

    td {
      color: var(--text-secondary);
    }

    td code {
      font-size: 0.813rem;
    }

    /* Callouts */
    .callout {
      padding: 16px 20px;
      border-radius: 8px;
      margin: 16px 0 24px;
      border-left: 4px solid;
    }

    .callout-title {
      font-weight: 600;
      font-size: 0.875rem;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .callout p {
      margin: 0;
      font-size: 0.875rem;
    }

    .callout-info {
      background: rgba(59, 130, 246, 0.1);
      border-color: var(--blue);
    }

    .callout-info .callout-title {
      color: var(--blue);
    }

    .callout-warning {
      background: rgba(234, 179, 8, 0.1);
      border-color: var(--yellow);
    }

    .callout-warning .callout-title {
      color: var(--yellow);
    }

    .callout-success {
      background: rgba(34, 197, 94, 0.1);
      border-color: var(--green);
    }

    .callout-success .callout-title {
      color: var(--green);
    }

    .callout-danger {
      background: rgba(239, 68, 68, 0.1);
      border-color: #ef4444;
    }

    .callout-danger .callout-title {
      color: #ef4444;
    }

    /* Lists */
    ul, ol {
      margin: 16px 0 24px;
      padding-left: 24px;
      color: var(--text-secondary);
    }

    li {
      margin-bottom: 8px;
    }

    li code {
      font-size: 0.813rem;
    }

    /* Badges */
    .badge {
      display: inline-block;
      padding: 2px 8px;
      font-size: 0.75rem;
      font-weight: 500;
      border-radius: 4px;
      margin-left: 8px;
    }

    .badge-new {
      background: rgba(34, 197, 94, 0.2);
      color: var(--green);
    }

    .badge-pro {
      background: rgba(168, 85, 247, 0.2);
      color: var(--purple);
    }

    /* Cards */
    .card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 16px;
      margin: 24px 0;
    }

    .card {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 20px;
      transition: border-color 0.15s;
    }

    .card:hover {
      border-color: var(--accent);
    }

    .card h4 {
      margin-top: 0;
      margin-bottom: 8px;
    }

    .card p {
      font-size: 0.875rem;
      margin: 0;
    }

    /* Steps */
    .steps {
      counter-reset: step;
      margin: 24px 0;
    }

    .step {
      position: relative;
      padding-left: 48px;
      padding-bottom: 24px;
      border-left: 2px solid var(--border);
      margin-left: 16px;
    }

    .step:last-child {
      border-left-color: transparent;
      padding-bottom: 0;
    }

    .step::before {
      counter-increment: step;
      content: counter(step);
      position: absolute;
      left: -17px;
      top: 0;
      width: 32px;
      height: 32px;
      background: var(--accent);
      color: white;
      border-radius: 50%;
      font-weight: 600;
      font-size: 0.875rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .step h4 {
      margin-top: 0;
    }

    /* API Reference */
    .api-method {
      display: inline-block;
      padding: 4px 10px;
      font-size: 0.75rem;
      font-weight: 600;
      border-radius: 4px;
      margin-right: 8px;
    }

    .api-method-get { background: rgba(34, 197, 94, 0.2); color: var(--green); }
    .api-method-post { background: rgba(59, 130, 246, 0.2); color: var(--blue); }
    .api-method-put { background: rgba(234, 179, 8, 0.2); color: var(--yellow); }
    .api-method-delete { background: rgba(239, 68, 68, 0.2); color: #ef4444; }

    .api-endpoint {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.875rem;
    }

    /* Search */
    .search-box {
      padding: 16px 24px;
      margin-bottom: 16px;
    }

    .search-input {
      width: 100%;
      padding: 10px 14px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 0.875rem;
      outline: none;
    }

    .search-input:focus {
      border-color: var(--accent);
    }

    .search-input::placeholder {
      color: var(--text-muted);
    }

    /* Responsive */
    @media (max-width: 1024px) {
      .sidebar {
        transform: translateX(-100%);
        z-index: 100;
        transition: transform 0.3s;
      }

      .sidebar.open {
        transform: translateX(0);
      }

      .main-content {
        margin-left: 0;
        padding: 32px 24px;
      }
    }

    /* Mobile menu toggle */
    .mobile-menu-toggle {
      display: none;
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 48px;
      height: 48px;
      background: var(--accent);
      border: none;
      border-radius: 50%;
      color: white;
      font-size: 1.5rem;
      cursor: pointer;
      z-index: 101;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    @media (max-width: 1024px) {
      .mobile-menu-toggle {
        display: flex;
        align-items: center;
        justify-content: center;
      }
    }

    /* TOC */
    .toc {
      position: fixed;
      right: 32px;
      top: 100px;
      width: 200px;
      font-size: 0.813rem;
    }

    .toc-title {
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 0.75rem;
      margin-bottom: 12px;
    }

    .toc-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .toc-list a {
      display: block;
      padding: 4px 0;
      color: var(--text-secondary);
      text-decoration: none;
      border-left: 2px solid transparent;
      padding-left: 12px;
      margin-left: -2px;
    }

    .toc-list a:hover,
    .toc-list a.active {
      color: var(--text);
      border-left-color: var(--accent);
    }

    @media (max-width: 1400px) {
      .toc {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div class="docs-layout">
    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <a href="../" class="sidebar-logo">
          <span>‚ö°</span> flashQ
        </a>
        <div class="sidebar-version">v0.1.5</div>
      </div>

      <div class="search-box">
        <input type="text" class="search-input" placeholder="Search docs..." id="search">
      </div>

      <div class="sidebar-section">
        <div class="sidebar-section-title">Getting Started</div>
        <ul class="sidebar-nav">
          <li><a href="#introduction" class="active">Introduction</a></li>
          <li><a href="#installation">Installation</a></li>
          <li><a href="#quickstart">Quick Start</a></li>
          <li><a href="#concepts">Core Concepts</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-section-title">Guides</div>
        <ul class="sidebar-nav">
          <li><a href="#queue-api">Queue API</a></li>
          <li><a href="#worker-api">Worker API</a></li>
          <li><a href="#job-options">Job Options</a></li>
          <li><a href="#job-dependencies">Job Dependencies</a></li>
          <li><a href="#rate-limiting">Rate Limiting</a></li>
          <li><a href="#retries">Retries & Backoff</a></li>
          <li><a href="#events">Events</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-section-title">AI Workloads</div>
        <ul class="sidebar-nav">
          <li><a href="#ai-overview">Overview</a></li>
          <li><a href="#llm-pipelines">LLM Pipelines</a></li>
          <li><a href="#rag-workflows">RAG Workflows</a></li>
          <li><a href="#batch-inference">Batch Inference</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-section-title">Features</div>
        <ul class="sidebar-nav">
          <li><a href="#kv-storage">KV Storage</a></li>
          <li><a href="#pubsub">Pub/Sub</a></li>
          <li><a href="#cron-jobs">Cron Jobs</a></li>
          <li><a href="#dead-letter-queue">Dead Letter Queue</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-section-title">Deployment</div>
        <ul class="sidebar-nav">
          <li><a href="#self-hosting">Self-Hosting</a></li>
          <li><a href="#docker">Docker</a></li>
          <li><a href="#configuration">Configuration</a></li>
          <li><a href="#clustering">Clustering (HA)</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-section-title">Migration</div>
        <ul class="sidebar-nav">
          <li><a href="#from-bullmq">From BullMQ</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-section-title">Reference</div>
        <ul class="sidebar-nav">
          <li><a href="#api-reference">API Reference</a></li>
          <li><a href="#cli">CLI Reference</a></li>
          <li><a href="#troubleshooting">Troubleshooting</a></li>
        </ul>
      </div>
    </aside>

    <!-- Main Content -->
    <main class="main-content">

      <!-- Introduction -->
      <section id="introduction">
        <h1>flashQ Documentation</h1>
        <p class="lead">
          flashQ is a high-performance job queue built with Rust. It provides a BullMQ-compatible API
          without requiring Redis, making it perfect for AI workloads, LLM pipelines, and high-throughput applications.
        </p>

        <div class="card-grid">
          <a href="#quickstart" class="card">
            <h4>üöÄ Quick Start</h4>
            <p>Get up and running in under 5 minutes with Docker and TypeScript.</p>
          </a>
          <a href="#ai-overview" class="card">
            <h4>ü§ñ AI Workloads</h4>
            <p>Learn how to build LLM pipelines, RAG workflows, and batch inference.</p>
          </a>
          <a href="#from-bullmq" class="card">
            <h4>üì¶ Migration</h4>
            <p>Already using BullMQ? Migrate in minutes with the same API.</p>
          </a>
          <a href="#api-reference" class="card">
            <h4>üìö API Reference</h4>
            <p>Complete reference for Queue, Worker, and all job options.</p>
          </a>
        </div>

        <h3>Why flashQ?</h3>
        <table>
          <thead>
            <tr>
              <th>Feature</th>
              <th>flashQ</th>
              <th>BullMQ + Redis</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>External dependencies</td>
              <td>None</td>
              <td>Redis server required</td>
            </tr>
            <tr>
              <td>Throughput</td>
              <td>300K jobs/sec</td>
              <td>~30K jobs/sec</td>
            </tr>
            <tr>
              <td>Max payload</td>
              <td>10 MB</td>
              <td>~5 MB recommended</td>
            </tr>
            <tr>
              <td>API compatibility</td>
              <td colspan="2">Same BullMQ-style API</td>
            </tr>
          </tbody>
        </table>
      </section>

      <!-- Installation -->
      <section id="installation">
        <h2>Installation</h2>

        <h3>Server</h3>
        <p>Start the flashQ server using Docker (recommended) or download the binary.</p>

        <h4>Docker (Recommended)</h4>
        <div class="code-block">
          <div class="code-block-header">
            <span>Terminal</span>
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          </div>
          <pre><code><span class="token-comment"># Pull multi-arch image (amd64 + arm64)</span>
docker pull ghcr.io/egeominotti/flashq:latest

<span class="token-comment"># Run with dashboard enabled</span>
docker run -d --name flashq \
  -p 6789:6789 \
  -p 6790:6790 \
  -e HTTP=1 \
  ghcr.io/egeominotti/flashq:latest</code></pre>
        </div>

        <h4>Binary</h4>
        <div class="code-block">
          <div class="code-block-header">
            <span>Terminal</span>
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          </div>
          <pre><code><span class="token-comment"># Linux x86_64</span>
curl -L https://github.com/egeominotti/flashq/releases/latest/download/flashq-linux-x86_64.tar.gz | tar xz
./flashq-server

<span class="token-comment"># macOS Apple Silicon</span>
curl -L https://github.com/egeominotti/flashq/releases/latest/download/flashq-macos-arm64.tar.gz | tar xz
./flashq-server</code></pre>
        </div>

        <h3>SDK</h3>
        <p>Install the TypeScript SDK in your project:</p>

        <div class="code-block">
          <div class="code-block-header">
            <span>Terminal</span>
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          </div>
          <pre><code><span class="token-comment"># Using bun</span>
bun add flashq

<span class="token-comment"># Using npm</span>
npm install flashq

<span class="token-comment"># Using yarn</span>
yarn add flashq</code></pre>
        </div>

        <div class="callout callout-info">
          <div class="callout-title">üí° TypeScript Support</div>
          <p>flashQ includes built-in TypeScript definitions. No additional @types package needed.</p>
        </div>
      </section>

      <!-- Quick Start -->
      <section id="quickstart">
        <h2>Quick Start</h2>
        <p>Get your first job queue running in under 5 minutes.</p>

        <div class="steps">
          <div class="step">
            <h4>Start the server</h4>
            <div class="code-block">
              <pre><code>docker run -d -p 6789:6789 ghcr.io/egeominotti/flashq:latest</code></pre>
            </div>
          </div>

          <div class="step">
            <h4>Install the SDK</h4>
            <div class="code-block">
              <pre><code>bun add flashq</code></pre>
            </div>
          </div>

          <div class="step">
            <h4>Create a queue and add jobs</h4>
            <div class="code-block">
              <div class="code-block-header">
                <span>producer.ts</span>
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
              </div>
              <pre><code><span class="token-keyword">import</span> { Queue } <span class="token-keyword">from</span> <span class="token-string">'flashq'</span>;

<span class="token-keyword">const</span> queue = <span class="token-keyword">new</span> <span class="token-function">Queue</span>(<span class="token-string">'emails'</span>);

<span class="token-comment">// Add a job</span>
<span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'send-welcome'</span>, {
  to: <span class="token-string">'user@example.com'</span>,
  subject: <span class="token-string">'Welcome!'</span>
});

console.<span class="token-function">log</span>(<span class="token-string">'Job added!'</span>);</code></pre>
            </div>
          </div>

          <div class="step">
            <h4>Process jobs with a worker</h4>
            <div class="code-block">
              <div class="code-block-header">
                <span>worker.ts</span>
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
              </div>
              <pre><code><span class="token-keyword">import</span> { Worker } <span class="token-keyword">from</span> <span class="token-string">'flashq'</span>;

<span class="token-keyword">const</span> worker = <span class="token-keyword">new</span> <span class="token-function">Worker</span>(<span class="token-string">'emails'</span>, <span class="token-keyword">async</span> (job) => {
  console.<span class="token-function">log</span>(<span class="token-string">`Sending email to ${job.data.to}`</span>);

  <span class="token-comment">// Your email sending logic here</span>
  <span class="token-keyword">await</span> <span class="token-function">sendEmail</span>(job.data);

  <span class="token-keyword">return</span> { sent: <span class="token-keyword">true</span> };
});

worker.<span class="token-function">on</span>(<span class="token-string">'completed'</span>, (job, result) => {
  console.<span class="token-function">log</span>(<span class="token-string">`Job ${job.id} completed`</span>);
});

worker.<span class="token-function">on</span>(<span class="token-string">'failed'</span>, (job, error) => {
  console.<span class="token-function">error</span>(<span class="token-string">`Job ${job.id} failed: ${error.message}`</span>);
});</code></pre>
            </div>
          </div>
        </div>

        <div class="callout callout-success">
          <div class="callout-title">‚úÖ That's it!</div>
          <p>Your job queue is now running. The worker will automatically process jobs as they're added to the queue.</p>
        </div>
      </section>

      <!-- Core Concepts -->
      <section id="concepts">
        <h2>Core Concepts</h2>

        <h3>Queues</h3>
        <p>A <strong>Queue</strong> is a named container for jobs. Jobs in a queue are processed in priority order (highest first), with FIFO ordering for jobs of the same priority.</p>
        <div class="code-block">
          <pre><code><span class="token-keyword">const</span> emailQueue = <span class="token-keyword">new</span> <span class="token-function">Queue</span>(<span class="token-string">'emails'</span>);
<span class="token-keyword">const</span> reportQueue = <span class="token-keyword">new</span> <span class="token-function">Queue</span>(<span class="token-string">'reports'</span>);</code></pre>
        </div>

        <h3>Jobs</h3>
        <p>A <strong>Job</strong> is a unit of work with a name, data payload, and optional configuration. Jobs progress through states: <code>waiting</code> ‚Üí <code>active</code> ‚Üí <code>completed</code> or <code>failed</code>.</p>
        <div class="code-block">
          <pre><code><span class="token-keyword">const</span> job = <span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'process-image'</span>, {
  imageUrl: <span class="token-string">'https://example.com/image.jpg'</span>,
  filters: [<span class="token-string">'resize'</span>, <span class="token-string">'compress'</span>]
}, {
  priority: <span class="token-number">10</span>,
  attempts: <span class="token-number">3</span>
});</code></pre>
        </div>

        <h3>Workers</h3>
        <p>A <strong>Worker</strong> processes jobs from a queue. Workers can run concurrently and automatically handle job acknowledgment, retries, and error handling.</p>
        <div class="code-block">
          <pre><code><span class="token-keyword">const</span> worker = <span class="token-keyword">new</span> <span class="token-function">Worker</span>(<span class="token-string">'emails'</span>, processor, {
  concurrency: <span class="token-number">10</span>  <span class="token-comment">// Process 10 jobs in parallel</span>
});</code></pre>
        </div>

        <h3>Job States</h3>
        <table>
          <thead>
            <tr>
              <th>State</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>waiting</code></td>
              <td>Job is queued and ready to be processed</td>
            </tr>
            <tr>
              <td><code>delayed</code></td>
              <td>Job is scheduled to run at a future time</td>
            </tr>
            <tr>
              <td><code>active</code></td>
              <td>Job is currently being processed by a worker</td>
            </tr>
            <tr>
              <td><code>completed</code></td>
              <td>Job finished successfully</td>
            </tr>
            <tr>
              <td><code>failed</code></td>
              <td>Job failed and exhausted all retry attempts (in DLQ)</td>
            </tr>
            <tr>
              <td><code>waiting-children</code></td>
              <td>Job is waiting for dependent jobs to complete</td>
            </tr>
          </tbody>
        </table>
      </section>

      <!-- Queue API -->
      <section id="queue-api">
        <h2>Queue API</h2>
        <p>The Queue class provides methods for adding jobs and managing queue state.</p>

        <h3>Constructor</h3>
        <div class="code-block">
          <pre><code><span class="token-keyword">const</span> queue = <span class="token-keyword">new</span> <span class="token-function">Queue</span>(name, options?);</code></pre>
        </div>

        <table>
          <thead>
            <tr>
              <th>Option</th>
              <th>Type</th>
              <th>Default</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>host</code></td>
              <td>string</td>
              <td><code>'localhost'</code></td>
              <td>Server hostname</td>
            </tr>
            <tr>
              <td><code>port</code></td>
              <td>number</td>
              <td><code>6789</code></td>
              <td>Server port</td>
            </tr>
            <tr>
              <td><code>token</code></td>
              <td>string</td>
              <td>-</td>
              <td>Authentication token</td>
            </tr>
          </tbody>
        </table>

        <h3>Methods</h3>

        <h4><code>add(name, data, opts?)</code></h4>
        <p>Add a single job to the queue.</p>
        <div class="code-block">
          <pre><code><span class="token-keyword">const</span> job = <span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'send-email'</span>, {
  to: <span class="token-string">'user@example.com'</span>
}, {
  priority: <span class="token-number">10</span>,
  delay: <span class="token-number">5000</span>,
  attempts: <span class="token-number">3</span>
});

console.<span class="token-function">log</span>(job.id); <span class="token-comment">// Unique job ID</span></code></pre>
        </div>

        <h4><code>addBulk(jobs)</code></h4>
        <p>Add multiple jobs in a single batch operation. More efficient than calling <code>add()</code> multiple times.</p>
        <div class="code-block">
          <pre><code><span class="token-keyword">const</span> jobs = <span class="token-keyword">await</span> queue.<span class="token-function">addBulk</span>([
  { name: <span class="token-string">'send'</span>, data: { to: <span class="token-string">'a@test.com'</span> } },
  { name: <span class="token-string">'send'</span>, data: { to: <span class="token-string">'b@test.com'</span> }, opts: { priority: <span class="token-number">10</span> } },
  { name: <span class="token-string">'send'</span>, data: { to: <span class="token-string">'c@test.com'</span> }, opts: { delay: <span class="token-number">5000</span> } },
]);</code></pre>
        </div>

        <h4><code>getJob(jobId)</code></h4>
        <p>Get a job by its ID, including current state and data.</p>
        <div class="code-block">
          <pre><code><span class="token-keyword">const</span> job = <span class="token-keyword">await</span> queue.<span class="token-function">getJob</span>(<span class="token-number">123</span>);
console.<span class="token-function">log</span>(job.state);  <span class="token-comment">// 'completed'</span>
console.<span class="token-function">log</span>(job.result); <span class="token-comment">// { sent: true }</span></code></pre>
        </div>

        <h4><code>finished(jobId, timeout?)</code> <span class="badge badge-new">New</span></h4>
        <p>Wait for a job to complete and return its result. Perfect for synchronous workflows.</p>
        <div class="code-block">
          <pre><code><span class="token-keyword">const</span> job = <span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'generate'</span>, { prompt });
<span class="token-keyword">const</span> result = <span class="token-keyword">await</span> queue.<span class="token-function">finished</span>(job.id, <span class="token-number">30000</span>); <span class="token-comment">// 30s timeout</span>
console.<span class="token-function">log</span>(result); <span class="token-comment">// Worker's return value</span></code></pre>
        </div>

        <h4><code>getJobCounts()</code></h4>
        <p>Get counts of jobs in each state.</p>
        <div class="code-block">
          <pre><code><span class="token-keyword">const</span> counts = <span class="token-keyword">await</span> queue.<span class="token-function">getJobCounts</span>();
<span class="token-comment">// { waiting: 10, active: 5, completed: 100, failed: 2, delayed: 3 }</span></code></pre>
        </div>

        <h4><code>pause()</code> / <code>resume()</code></h4>
        <p>Pause or resume job processing on the queue.</p>
        <div class="code-block">
          <pre><code><span class="token-keyword">await</span> queue.<span class="token-function">pause</span>();   <span class="token-comment">// Workers stop pulling jobs</span>
<span class="token-keyword">await</span> queue.<span class="token-function">resume</span>();  <span class="token-comment">// Workers resume pulling jobs</span></code></pre>
        </div>

        <h4><code>drain()</code></h4>
        <p>Remove all waiting jobs from the queue.</p>
        <div class="code-block">
          <pre><code><span class="token-keyword">await</span> queue.<span class="token-function">drain</span>(); <span class="token-comment">// Clear waiting jobs only</span></code></pre>
        </div>

        <h4><code>obliterate()</code></h4>
        <p>Remove all data associated with the queue (jobs, DLQ, settings).</p>
        <div class="code-block">
          <pre><code><span class="token-keyword">await</span> queue.<span class="token-function">obliterate</span>(); <span class="token-comment">// Nuclear option - removes everything</span></code></pre>
        </div>
        <div class="callout callout-danger">
          <div class="callout-title">‚ö†Ô∏è Warning</div>
          <p><code>obliterate()</code> is irreversible. All jobs and queue data will be permanently deleted.</p>
        </div>
      </section>

      <!-- Job Options -->
      <section id="job-options">
        <h2>Job Options</h2>
        <p>Configure job behavior with these options when calling <code>queue.add()</code>.</p>

        <table>
          <thead>
            <tr>
              <th>Option</th>
              <th>Type</th>
              <th>Default</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>priority</code></td>
              <td>number</td>
              <td><code>0</code></td>
              <td>Higher priority jobs are processed first</td>
            </tr>
            <tr>
              <td><code>delay</code></td>
              <td>number</td>
              <td><code>0</code></td>
              <td>Delay in milliseconds before job becomes available</td>
            </tr>
            <tr>
              <td><code>attempts</code></td>
              <td>number</td>
              <td><code>1</code></td>
              <td>Number of retry attempts on failure</td>
            </tr>
            <tr>
              <td><code>backoff</code></td>
              <td>number | object</td>
              <td>-</td>
              <td>Backoff strategy for retries</td>
            </tr>
            <tr>
              <td><code>timeout</code></td>
              <td>number</td>
              <td>-</td>
              <td>Job processing timeout in milliseconds</td>
            </tr>
            <tr>
              <td><code>jobId</code></td>
              <td>string</td>
              <td>-</td>
              <td>Custom job ID for idempotency</td>
            </tr>
            <tr>
              <td><code>depends_on</code></td>
              <td>number[]</td>
              <td>-</td>
              <td>Job IDs that must complete before this job runs</td>
            </tr>
            <tr>
              <td><code>ttl</code></td>
              <td>number</td>
              <td>-</td>
              <td>Time-to-live: auto-fail if not processed in time</td>
            </tr>
          </tbody>
        </table>

        <h3>Priority</h3>
        <p>Jobs with higher priority values are processed first.</p>
        <div class="code-block">
          <pre><code><span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'low'</span>, data, { priority: <span class="token-number">1</span> });
<span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'high'</span>, data, { priority: <span class="token-number">100</span> }); <span class="token-comment">// Processed first</span>
<span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'urgent'</span>, data, { priority: <span class="token-number">1000</span> }); <span class="token-comment">// Processed before 'high'</span></code></pre>
        </div>

        <h3>Delay</h3>
        <p>Schedule a job to run after a specified delay.</p>
        <div class="code-block">
          <pre><code><span class="token-comment">// Run after 5 seconds</span>
<span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'reminder'</span>, data, { delay: <span class="token-number">5000</span> });

<span class="token-comment">// Run after 1 hour</span>
<span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'daily-report'</span>, data, { delay: <span class="token-number">60</span> * <span class="token-number">60</span> * <span class="token-number">1000</span> });</code></pre>
        </div>

        <h3>Backoff</h3>
        <p>Configure retry delay strategy.</p>
        <div class="code-block">
          <pre><code><span class="token-comment">// Fixed delay: retry after 5s each time</span>
<span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'job'</span>, data, {
  attempts: <span class="token-number">3</span>,
  backoff: <span class="token-number">5000</span>
});

<span class="token-comment">// Exponential backoff: 1s, 2s, 4s, 8s...</span>
<span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'job'</span>, data, {
  attempts: <span class="token-number">5</span>,
  backoff: {
    type: <span class="token-string">'exponential'</span>,
    delay: <span class="token-number">1000</span>
  }
});</code></pre>
        </div>

        <h3>Custom Job ID (Idempotency)</h3>
        <p>Use <code>jobId</code> to prevent duplicate jobs. If a job with the same ID already exists, the existing job is returned.</p>
        <div class="code-block">
          <pre><code><span class="token-comment">// Only one job per order</span>
<span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'process-order'</span>, orderData, {
  jobId: <span class="token-string">`order-${orderId}`</span>
});

<span class="token-comment">// Second call with same jobId returns existing job</span>
<span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'process-order'</span>, orderData, {
  jobId: <span class="token-string">`order-${orderId}`</span>
}); <span class="token-comment">// No duplicate created</span></code></pre>
        </div>
      </section>

      <!-- Job Dependencies -->
      <section id="job-dependencies">
        <h2>Job Dependencies</h2>
        <p>Create workflows where jobs wait for other jobs to complete before running.</p>

        <div class="code-block">
          <pre><code><span class="token-comment">// Step 1: Fetch data</span>
<span class="token-keyword">const</span> fetchJob = <span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'fetch'</span>, { url });

<span class="token-comment">// Step 2: Process (waits for fetch to complete)</span>
<span class="token-keyword">const</span> processJob = <span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'process'</span>, { data }, {
  depends_on: [fetchJob.id]
});

<span class="token-comment">// Step 3: Save (waits for process to complete)</span>
<span class="token-keyword">const</span> saveJob = <span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'save'</span>, { destination }, {
  depends_on: [processJob.id]
});

<span class="token-comment">// Wait for the final result</span>
<span class="token-keyword">const</span> result = <span class="token-keyword">await</span> queue.<span class="token-function">finished</span>(saveJob.id);</code></pre>
        </div>

        <h3>Multiple Dependencies</h3>
        <p>A job can depend on multiple jobs. It will only run when ALL dependencies have completed.</p>
        <div class="code-block">
          <pre><code><span class="token-comment">// Fan-out: multiple parallel jobs</span>
<span class="token-keyword">const</span> job1 = <span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'task1'</span>, data1);
<span class="token-keyword">const</span> job2 = <span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'task2'</span>, data2);
<span class="token-keyword">const</span> job3 = <span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'task3'</span>, data3);

<span class="token-comment">// Fan-in: aggregate results (waits for all 3)</span>
<span class="token-keyword">const</span> aggregateJob = <span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'aggregate'</span>, {}, {
  depends_on: [job1.id, job2.id, job3.id]
});</code></pre>
        </div>

        <div class="callout callout-info">
          <div class="callout-title">üí° AI Pipeline Example</div>
          <p>Dependencies are perfect for RAG pipelines: embed ‚Üí search ‚Üí generate. See <a href="#rag-workflows">RAG Workflows</a> for a complete example.</p>
        </div>
      </section>

      <!-- Worker API -->
      <section id="worker-api">
        <h2>Worker API</h2>
        <p>Workers process jobs from a queue. They automatically handle job acknowledgment, retries, and error handling.</p>

        <h3>Constructor</h3>
        <div class="code-block">
          <pre><code><span class="token-keyword">const</span> worker = <span class="token-keyword">new</span> <span class="token-function">Worker</span>(queueName, processor, options?);</code></pre>
        </div>

        <h4>Parameters</h4>
        <table>
          <thead>
            <tr>
              <th>Parameter</th>
              <th>Type</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>queueName</code></td>
              <td>string</td>
              <td>Name of the queue to process</td>
            </tr>
            <tr>
              <td><code>processor</code></td>
              <td>function</td>
              <td>Async function that processes each job</td>
            </tr>
            <tr>
              <td><code>options</code></td>
              <td>object</td>
              <td>Worker configuration options</td>
            </tr>
          </tbody>
        </table>

        <h4>Options</h4>
        <table>
          <thead>
            <tr>
              <th>Option</th>
              <th>Type</th>
              <th>Default</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>concurrency</code></td>
              <td>number</td>
              <td><code>1</code></td>
              <td>Number of jobs to process in parallel</td>
            </tr>
            <tr>
              <td><code>autorun</code></td>
              <td>boolean</td>
              <td><code>true</code></td>
              <td>Start processing immediately</td>
            </tr>
            <tr>
              <td><code>host</code></td>
              <td>string</td>
              <td><code>'localhost'</code></td>
              <td>Server hostname</td>
            </tr>
            <tr>
              <td><code>port</code></td>
              <td>number</td>
              <td><code>6789</code></td>
              <td>Server port</td>
            </tr>
          </tbody>
        </table>

        <h3>Processor Function</h3>
        <p>The processor function receives a job object and should return a result (or throw an error).</p>
        <div class="code-block">
          <pre><code><span class="token-keyword">const</span> worker = <span class="token-keyword">new</span> <span class="token-function">Worker</span>(<span class="token-string">'emails'</span>, <span class="token-keyword">async</span> (job) => {
  <span class="token-comment">// Access job properties</span>
  console.<span class="token-function">log</span>(job.id);       <span class="token-comment">// Unique job ID</span>
  console.<span class="token-function">log</span>(job.name);     <span class="token-comment">// Job name</span>
  console.<span class="token-function">log</span>(job.data);     <span class="token-comment">// Job payload</span>
  console.<span class="token-function">log</span>(job.attempts); <span class="token-comment">// Current attempt number</span>

  <span class="token-comment">// Do work...</span>
  <span class="token-keyword">const</span> result = <span class="token-keyword">await</span> <span class="token-function">processJob</span>(job.data);

  <span class="token-comment">// Return result (stored with the job)</span>
  <span class="token-keyword">return</span> result;
});</code></pre>
        </div>

        <h3>Concurrency</h3>
        <p>Process multiple jobs in parallel for better throughput.</p>
        <div class="code-block">
          <pre><code><span class="token-comment">// Process 10 jobs concurrently</span>
<span class="token-keyword">const</span> worker = <span class="token-keyword">new</span> <span class="token-function">Worker</span>(<span class="token-string">'images'</span>, processor, {
  concurrency: <span class="token-number">10</span>
});</code></pre>
        </div>
        <div class="callout callout-warning">
          <div class="callout-title">‚ö†Ô∏è Concurrency Tips</div>
          <p>Set concurrency based on your workload. CPU-bound tasks benefit from concurrency matching CPU cores. I/O-bound tasks (API calls, DB queries) can use higher concurrency.</p>
        </div>

        <h3>Graceful Shutdown</h3>
        <div class="code-block">
          <pre><code><span class="token-comment">// Close worker and wait for active jobs to finish</span>
<span class="token-keyword">await</span> worker.<span class="token-function">close</span>();

<span class="token-comment">// Handle process termination</span>
process.<span class="token-function">on</span>(<span class="token-string">'SIGTERM'</span>, <span class="token-keyword">async</span> () => {
  <span class="token-keyword">await</span> worker.<span class="token-function">close</span>();
  process.<span class="token-function">exit</span>(<span class="token-number">0</span>);
});</code></pre>
        </div>
      </section>

      <!-- Events -->
      <section id="events">
        <h2>Events</h2>
        <p>Workers emit events for job lifecycle changes.</p>

        <table>
          <thead>
            <tr>
              <th>Event</th>
              <th>Arguments</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>completed</code></td>
              <td><code>(job, result)</code></td>
              <td>Job completed successfully</td>
            </tr>
            <tr>
              <td><code>failed</code></td>
              <td><code>(job, error)</code></td>
              <td>Job failed (after all retries)</td>
            </tr>
            <tr>
              <td><code>error</code></td>
              <td><code>(error)</code></td>
              <td>Worker-level error</td>
            </tr>
            <tr>
              <td><code>active</code></td>
              <td><code>(job)</code></td>
              <td>Job started processing</td>
            </tr>
            <tr>
              <td><code>progress</code></td>
              <td><code>(job, progress)</code></td>
              <td>Job progress updated</td>
            </tr>
          </tbody>
        </table>

        <div class="code-block">
          <pre><code>worker.<span class="token-function">on</span>(<span class="token-string">'completed'</span>, (job, result) => {
  console.<span class="token-function">log</span>(<span class="token-string">`‚úÖ Job ${job.id} completed`</span>, result);
});

worker.<span class="token-function">on</span>(<span class="token-string">'failed'</span>, (job, error) => {
  console.<span class="token-function">error</span>(<span class="token-string">`‚ùå Job ${job.id} failed: ${error.message}`</span>);
  <span class="token-comment">// Send to error tracking (Sentry, etc.)</span>
});

worker.<span class="token-function">on</span>(<span class="token-string">'active'</span>, (job) => {
  console.<span class="token-function">log</span>(<span class="token-string">`üîÑ Job ${job.id} started`</span>);
});

worker.<span class="token-function">on</span>(<span class="token-string">'error'</span>, (error) => {
  console.<span class="token-function">error</span>(<span class="token-string">'Worker error:'</span>, error);
});</code></pre>
        </div>
      </section>

      <!-- Rate Limiting -->
      <section id="rate-limiting">
        <h2>Rate Limiting</h2>
        <p>Control job throughput to avoid overwhelming external APIs or services.</p>

        <div class="code-block">
          <pre><code><span class="token-keyword">import</span> { FlashQ } <span class="token-keyword">from</span> <span class="token-string">'flashq'</span>;

<span class="token-keyword">const</span> client = <span class="token-keyword">new</span> <span class="token-function">FlashQ</span>();

<span class="token-comment">// Limit to 100 jobs per second</span>
<span class="token-keyword">await</span> client.<span class="token-function">setRateLimit</span>(<span class="token-string">'openai-calls'</span>, <span class="token-number">100</span>);

<span class="token-comment">// Limit to 10 jobs per second (for expensive API)</span>
<span class="token-keyword">await</span> client.<span class="token-function">setRateLimit</span>(<span class="token-string">'anthropic-calls'</span>, <span class="token-number">10</span>);

<span class="token-comment">// Remove rate limit</span>
<span class="token-keyword">await</span> client.<span class="token-function">clearRateLimit</span>(<span class="token-string">'openai-calls'</span>);</code></pre>
        </div>

        <div class="callout callout-info">
          <div class="callout-title">üí° AI Cost Control</div>
          <p>Rate limiting is essential for controlling LLM API costs. Set limits based on your API tier and budget.</p>
        </div>

        <h3>Concurrency Limiting</h3>
        <p>Limit the number of jobs that can be processed simultaneously.</p>
        <div class="code-block">
          <pre><code><span class="token-comment">// Only allow 5 concurrent jobs in this queue</span>
<span class="token-keyword">await</span> client.<span class="token-function">setConcurrency</span>(<span class="token-string">'heavy-processing'</span>, <span class="token-number">5</span>);

<span class="token-comment">// Remove concurrency limit</span>
<span class="token-keyword">await</span> client.<span class="token-function">clearConcurrency</span>(<span class="token-string">'heavy-processing'</span>);</code></pre>
        </div>
      </section>

      <!-- AI Overview -->
      <section id="ai-overview">
        <h2>AI Workloads</h2>
        <p>flashQ is optimized for AI/ML workloads with features designed for LLM pipelines, RAG systems, and batch inference.</p>

        <div class="card-grid">
          <div class="card">
            <h4>üîó Job Dependencies</h4>
            <p>Chain jobs for multi-step AI workflows. Perfect for RAG: embed ‚Üí search ‚Üí generate.</p>
          </div>
          <div class="card">
            <h4>‚è±Ô∏è Rate Limiting</h4>
            <p>Control API costs with per-queue rate limits. Never exceed your OpenAI/Anthropic quota.</p>
          </div>
          <div class="card">
            <h4>üì¶ Large Payloads</h4>
            <p>10MB payload support for embeddings, images, and large context windows.</p>
          </div>
          <div class="card">
            <h4>üîÑ Smart Retries</h4>
            <p>Automatic retries with exponential backoff. Handle API rate limits gracefully.</p>
          </div>
        </div>
      </section>

      <!-- RAG Workflows -->
      <section id="rag-workflows">
        <h2>RAG Workflows</h2>
        <p>Build Retrieval-Augmented Generation pipelines with job dependencies.</p>

        <div class="code-block">
          <div class="code-block-header">
            <span>rag-pipeline.ts</span>
            <button class="copy-btn" onclick="copyCode(this)">Copy</button>
          </div>
          <pre><code><span class="token-keyword">import</span> { Queue, Worker } <span class="token-keyword">from</span> <span class="token-string">'flashq'</span>;

<span class="token-keyword">const</span> rag = <span class="token-keyword">new</span> <span class="token-function">Queue</span>(<span class="token-string">'rag-pipeline'</span>);

<span class="token-comment">// Create RAG pipeline</span>
<span class="token-keyword">async function</span> <span class="token-function">askQuestion</span>(question: <span class="token-variable">string</span>) {
  <span class="token-comment">// Step 1: Embed the question</span>
  <span class="token-keyword">const</span> embedJob = <span class="token-keyword">await</span> rag.<span class="token-function">add</span>(<span class="token-string">'embed'</span>, { text: question });

  <span class="token-comment">// Step 2: Search vector DB (waits for embedding)</span>
  <span class="token-keyword">const</span> searchJob = <span class="token-keyword">await</span> rag.<span class="token-function">add</span>(<span class="token-string">'search'</span>, { query: question }, {
    depends_on: [embedJob.id]
  });

  <span class="token-comment">// Step 3: Generate answer (waits for search)</span>
  <span class="token-keyword">const</span> generateJob = <span class="token-keyword">await</span> rag.<span class="token-function">add</span>(<span class="token-string">'generate'</span>, { question }, {
    depends_on: [searchJob.id],
    priority: <span class="token-number">10</span>  <span class="token-comment">// Higher priority for final step</span>
  });

  <span class="token-comment">// Wait for result</span>
  <span class="token-keyword">return</span> rag.<span class="token-function">finished</span>(generateJob.id);
}

<span class="token-comment">// Workers for each step</span>
<span class="token-keyword">new</span> <span class="token-function">Worker</span>(<span class="token-string">'rag-pipeline'</span>, <span class="token-keyword">async</span> (job) => {
  <span class="token-keyword">switch</span> (job.name) {
    <span class="token-keyword">case</span> <span class="token-string">'embed'</span>:
      <span class="token-keyword">return</span> <span class="token-keyword">await</span> openai.embeddings.<span class="token-function">create</span>({
        model: <span class="token-string">'text-embedding-3-small'</span>,
        input: job.data.text
      });

    <span class="token-keyword">case</span> <span class="token-string">'search'</span>:
      <span class="token-keyword">return</span> <span class="token-keyword">await</span> vectorDb.<span class="token-function">search</span>(job.data.query, { limit: <span class="token-number">5</span> });

    <span class="token-keyword">case</span> <span class="token-string">'generate'</span>:
      <span class="token-keyword">return</span> <span class="token-keyword">await</span> openai.chat.completions.<span class="token-function">create</span>({
        model: <span class="token-string">'gpt-4'</span>,
        messages: [{ role: <span class="token-string">'user'</span>, content: job.data.question }]
      });
  }
}, { concurrency: <span class="token-number">10</span> });

<span class="token-comment">// Usage</span>
<span class="token-keyword">const</span> answer = <span class="token-keyword">await</span> <span class="token-function">askQuestion</span>(<span class="token-string">'What is flashQ?'</span>);
console.<span class="token-function">log</span>(answer);</code></pre>
        </div>
      </section>

      <!-- Configuration -->
      <section id="configuration">
        <h2>Configuration</h2>
        <p>Configure the flashQ server with environment variables.</p>

        <table>
          <thead>
            <tr>
              <th>Variable</th>
              <th>Default</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>PORT</code></td>
              <td><code>6789</code></td>
              <td>TCP port for client connections</td>
            </tr>
            <tr>
              <td><code>HTTP</code></td>
              <td><code>0</code></td>
              <td>Enable HTTP API and dashboard (set to <code>1</code>)</td>
            </tr>
            <tr>
              <td><code>HTTP_PORT</code></td>
              <td><code>6790</code></td>
              <td>HTTP API port</td>
            </tr>
            <tr>
              <td><code>GRPC</code></td>
              <td><code>0</code></td>
              <td>Enable gRPC API (set to <code>1</code>)</td>
            </tr>
            <tr>
              <td><code>GRPC_PORT</code></td>
              <td><code>6791</code></td>
              <td>gRPC API port</td>
            </tr>
            <tr>
              <td><code>DATABASE_URL</code></td>
              <td>-</td>
              <td>PostgreSQL connection URL for persistence</td>
            </tr>
            <tr>
              <td><code>AUTH_TOKENS</code></td>
              <td>-</td>
              <td>Comma-separated list of valid auth tokens</td>
            </tr>
            <tr>
              <td><code>CLUSTER_MODE</code></td>
              <td><code>0</code></td>
              <td>Enable clustering (set to <code>1</code>)</td>
            </tr>
            <tr>
              <td><code>NODE_ID</code></td>
              <td>auto</td>
              <td>Unique node identifier for clustering</td>
            </tr>
          </tbody>
        </table>

        <h3>Example: Production Docker</h3>
        <div class="code-block">
          <pre><code>docker run -d --name flashq \
  -p 6789:6789 \
  -p 6790:6790 \
  -e HTTP=1 \
  -e DATABASE_URL=postgres://user:pass@db:5432/flashq \
  -e AUTH_TOKENS=secret1,secret2 \
  ghcr.io/egeominotti/flashq:latest</code></pre>
        </div>
      </section>

      <!-- Migration from BullMQ -->
      <section id="from-bullmq">
        <h2>Migration from BullMQ</h2>
        <p>flashQ uses a BullMQ-compatible API, making migration straightforward.</p>

        <div class="steps">
          <div class="step">
            <h4>Install flashQ SDK</h4>
            <div class="code-block">
              <pre><code>bun add flashq</code></pre>
            </div>
          </div>

          <div class="step">
            <h4>Start the flashQ server</h4>
            <div class="code-block">
              <pre><code>docker run -d -p 6789:6789 ghcr.io/egeominotti/flashq:latest</code></pre>
            </div>
          </div>

          <div class="step">
            <h4>Update your imports</h4>
            <div class="code-block">
              <pre><code><span class="token-comment">// Before (BullMQ)</span>
<span class="token-keyword">import</span> { Queue, Worker } <span class="token-keyword">from</span> <span class="token-string">'bullmq'</span>;

<span class="token-comment">// After (flashQ)</span>
<span class="token-keyword">import</span> { Queue, Worker } <span class="token-keyword">from</span> <span class="token-string">'flashq'</span>;</code></pre>
            </div>
          </div>

          <div class="step">
            <h4>Remove Redis configuration</h4>
            <div class="code-block">
              <pre><code><span class="token-comment">// Before (BullMQ)</span>
<span class="token-keyword">const</span> queue = <span class="token-keyword">new</span> <span class="token-function">Queue</span>(<span class="token-string">'emails'</span>, {
  connection: { host: <span class="token-string">'localhost'</span>, port: <span class="token-number">6379</span> }
});

<span class="token-comment">// After (flashQ) - no Redis needed!</span>
<span class="token-keyword">const</span> queue = <span class="token-keyword">new</span> <span class="token-function">Queue</span>(<span class="token-string">'emails'</span>);</code></pre>
            </div>
          </div>
        </div>

        <div class="callout callout-success">
          <div class="callout-title">‚úÖ That's it!</div>
          <p>Your code should work without any other changes. The Queue and Worker APIs are compatible.</p>
        </div>

        <h3>API Compatibility</h3>
        <table>
          <thead>
            <tr>
              <th>BullMQ Feature</th>
              <th>flashQ Support</th>
              <th>Notes</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>Queue.add()</code></td>
              <td>‚úÖ Full</td>
              <td></td>
            </tr>
            <tr>
              <td><code>Queue.addBulk()</code></td>
              <td>‚úÖ Full</td>
              <td></td>
            </tr>
            <tr>
              <td><code>Worker</code></td>
              <td>‚úÖ Full</td>
              <td></td>
            </tr>
            <tr>
              <td>Job priorities</td>
              <td>‚úÖ Full</td>
              <td></td>
            </tr>
            <tr>
              <td>Delayed jobs</td>
              <td>‚úÖ Full</td>
              <td></td>
            </tr>
            <tr>
              <td>Retries & backoff</td>
              <td>‚úÖ Full</td>
              <td></td>
            </tr>
            <tr>
              <td>Job events</td>
              <td>‚úÖ Full</td>
              <td></td>
            </tr>
            <tr>
              <td>Rate limiting</td>
              <td>‚úÖ Full</td>
              <td></td>
            </tr>
            <tr>
              <td>Job dependencies</td>
              <td>‚úÖ Full</td>
              <td></td>
            </tr>
            <tr>
              <td>Repeatable jobs</td>
              <td>‚úÖ Via cron</td>
              <td>Use <code>addCron()</code></td>
            </tr>
            <tr>
              <td>Flows</td>
              <td>‚úÖ Via depends_on</td>
              <td>Use job dependencies</td>
            </tr>
          </tbody>
        </table>
      </section>

      <!-- Troubleshooting -->
      <section id="troubleshooting">
        <h2>Troubleshooting</h2>

        <h3>Connection refused</h3>
        <p><strong>Error:</strong> <code>ECONNREFUSED 127.0.0.1:6789</code></p>
        <p><strong>Solution:</strong> Make sure the flashQ server is running:</p>
        <div class="code-block">
          <pre><code>docker ps | grep flashq</code></pre>
        </div>

        <h3>Job timeout</h3>
        <p><strong>Error:</strong> Job exceeds processing timeout</p>
        <p><strong>Solution:</strong> Increase the timeout in job options:</p>
        <div class="code-block">
          <pre><code><span class="token-keyword">await</span> queue.<span class="token-function">add</span>(<span class="token-string">'long-job'</span>, data, {
  timeout: <span class="token-number">300000</span> <span class="token-comment">// 5 minutes</span>
});</code></pre>
        </div>

        <h3>Job data too large</h3>
        <p><strong>Error:</strong> <code>Job data too large</code></p>
        <p><strong>Solution:</strong> flashQ supports up to 10MB payloads. If you need larger, store data externally and pass a reference.</p>

        <h3>Authentication failed</h3>
        <p><strong>Error:</strong> <code>AUTH_FAILED</code></p>
        <p><strong>Solution:</strong> Set the token in your client configuration:</p>
        <div class="code-block">
          <pre><code><span class="token-keyword">const</span> queue = <span class="token-keyword">new</span> <span class="token-function">Queue</span>(<span class="token-string">'emails'</span>, {
  token: <span class="token-string">'your-auth-token'</span>
});</code></pre>
        </div>
      </section>

    </main>
  </div>

  <!-- Mobile menu toggle -->
  <button class="mobile-menu-toggle" onclick="toggleSidebar()">‚ò∞</button>

  <script>
    function toggleSidebar() {
      document.getElementById('sidebar').classList.toggle('open');
    }

    function copyCode(btn) {
      const code = btn.parentElement.nextElementSibling.querySelector('code');
      navigator.clipboard.writeText(code.textContent);
      btn.textContent = 'Copied!';
      setTimeout(() => btn.textContent = 'Copy', 2000);
    }

    // Highlight active section on scroll
    const sections = document.querySelectorAll('section[id]');
    const navLinks = document.querySelectorAll('.sidebar-nav a');

    window.addEventListener('scroll', () => {
      let current = '';
      sections.forEach(section => {
        const sectionTop = section.offsetTop;
        if (scrollY >= sectionTop - 100) {
          current = section.getAttribute('id');
        }
      });

      navLinks.forEach(link => {
        link.classList.remove('active');
        if (link.getAttribute('href') === `#${current}`) {
          link.classList.add('active');
        }
      });
    });

    // Search functionality
    const searchInput = document.getElementById('search');
    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.toLowerCase();
      navLinks.forEach(link => {
        const text = link.textContent.toLowerCase();
        link.style.display = text.includes(query) ? 'block' : 'none';
      });
    });
  </script>
</body>
</html>
