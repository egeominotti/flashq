<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Job Queue Patterns for AI Applications - flashQ Blog</title>
  <meta name="description" content="Essential job queue patterns for building reliable AI applications: fan-out, sagas, circuit breakers, dead letter queues, and more.">
  <meta name="keywords" content="job queue patterns, ai architecture, saga pattern, circuit breaker, fan-out, background jobs">
  <meta name="robots" content="index, follow">

  <meta property="og:title" content="Job Queue Patterns for AI Applications">
  <meta property="og:description" content="Essential patterns for building reliable AI applications with job queues.">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://flashq.dev/blog/job-queue-patterns.html">
  <meta property="og:image" content="https://flashq.dev/og-image.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Job Queue Patterns for AI Applications">
  <meta name="twitter:image" content="https://flashq.dev/og-image.png">

  <link rel="canonical" href="https://flashq.dev/blog/job-queue-patterns.html">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>âš¡</text></svg>">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="styles.css">

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "Job Queue Patterns for AI Applications",
    "datePublished": "2026-01-19",
    "author": { "@type": "Organization", "name": "flashQ" }
  }
  </script>

  <!-- Breadcrumb Schema -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
      { "@type": "ListItem", "position": 1, "name": "Home", "item": "https://flashq.dev" },
      { "@type": "ListItem", "position": 2, "name": "Blog", "item": "https://flashq.dev/blog/" },
      { "@type": "ListItem", "position": 3, "name": "Job Queue Patterns", "item": "https://flashq.dev/blog/job-queue-patterns.html" }
    ]
  }
  </script>
  <!-- Highlight.js -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
</head>
<body>
  <nav>
    <div class="container wide">
      <a href="../" class="logo"><span>âš¡</span> flashQ</a>
      <div class="nav-links">
        <a href="../#features">Features</a>
        <a href="../blog/" class="active">Blog</a>
        <a href="../docs/">Docs</a>
        <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
        <a href="../docs/#quickstart" class="btn btn-primary">Get Started</a>
      </div>
      <button class="mobile-menu-btn" aria-label="Menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
  </nav>

  <div class="mobile-menu">
    <a href="../#features">Features</a>
    <a href="../blog/">Blog</a>
    <a href="../docs/">Docs</a>
    <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
    <a href="../docs/#quickstart" class="btn btn-primary">Get Started</a>
  </div>

  <header class="article-header header-tutorial">
    <div class="container">
      <span class="article-tag">Best Practices</span>
      <h1>Job Queue Patterns for AI Applications</h1>
      <div class="article-meta">
        <span>ğŸ“… January 19, 2026</span>
        <span>â±ï¸ 12 min read</span>
      </div>
    </div>
  </header>

  <article class="article-content">
    <div class="container">
      <p>Building reliable AI applications requires more than just calling APIs. You need patterns that handle failures gracefully, scale efficiently, and maintain data consistency. In this guide, we'll explore essential job queue patterns that every AI engineer should know.</p>

      <h2>1. Fan-Out Pattern</h2>

      <p>The fan-out pattern distributes work across multiple workers. It's perfect for batch processing where you need to process many items independently.</p>

      <pre><code class="language-plaintext">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Source  â”‚ â”€â”€â–¶ â”‚ Worker 1 â”‚ â”€â”€â–¶ â”‚ Results  â”‚
â”‚  Job    â”‚ â”€â”€â–¶ â”‚ Worker 2 â”‚ â”€â”€â–¶ â”‚ Collectorâ”‚
â”‚         â”‚ â”€â”€â–¶ â”‚ Worker 3 â”‚ â”€â”€â–¶ â”‚          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

      <p><strong>Use case:</strong> Processing 10,000 documents for embedding generation.</p>

      <pre><code class="language-typescript">async function fanOutEmbeddings(documents) {
  const queue = new Queue('embeddings');

  // Fan out: Create a job for each document
  const jobs = await queue.addBulk(
    documents.map(doc => ({
      name: 'embed',
      data: { id: doc.id, text: doc.content }
    }))
  );

  // Fan in: Collect results
  const collector = await queue.add('collect', {
    jobIds: jobs.map(j => j.id),
    totalCount: documents.length
  }, {
    depends_on: jobs.map(j => j.id)
  });

  return queue.finished(collector.id);
}</code></pre>

      <h2>2. Saga Pattern</h2>

      <p>The saga pattern manages distributed transactions by breaking them into steps, each with a compensating action for rollback.</p>

      <pre><code class="language-plaintext">â”Œâ”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”
â”‚Step 1 â”‚ â”€â”€â–¶ â”‚Step 2 â”‚ â”€â”€â–¶ â”‚Step 3 â”‚
â”‚       â”‚     â”‚       â”‚     â”‚       â”‚
â”‚Comp 1 â”‚ â—€â”€â”€ â”‚Comp 2 â”‚ â—€â”€â”€ â”‚Comp 3 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”˜
  (rollback chain if any step fails)</code></pre>

      <p><strong>Use case:</strong> AI-powered document processing with external API calls.</p>

      <pre><code class="language-typescript">const saga = {
  steps: [
    {
      name: 'extract',
      execute: async (data) => await extractText(data.file),
      compensate: async (data) => await deleteExtraction(data.extractionId)
    },
    {
      name: 'analyze',
      execute: async (data) => await openai.chat.completions.create({...}),
      compensate: async (data) => { /* no-op, API call can't be undone */ }
    },
    {
      name: 'store',
      execute: async (data) => await db.insert(data.analysis),
      compensate: async (data) => await db.delete(data.recordId)
    }
  ]
};

// Execute saga with automatic rollback on failure
async function executeSaga(saga, initialData) {
  const completedSteps = [];

  try {
    let data = initialData;
    for (const step of saga.steps) {
      data = await step.execute(data);
      completedSteps.push({ step, data });
    }
    return data;
  } catch (error) {
    // Rollback in reverse order
    for (const { step, data } of completedSteps.reverse()) {
      await step.compensate(data);
    }
    throw error;
  }
}</code></pre>

      <h2>3. Circuit Breaker Pattern</h2>

      <p>The circuit breaker prevents cascading failures by stopping requests to a failing service.</p>

      <pre><code class="language-plaintext">        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚         Circuit Breaker             â”‚
        â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
        â”‚  â”‚Closed â”‚â†’â”‚ Open  â”‚â†’â”‚Half-Open  â”‚ â”‚
        â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

      <p><strong>Use case:</strong> Protecting against OpenAI API outages.</p>

      <pre><code class="language-typescript">class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.failures = 0;
    this.threshold = threshold;
    this.timeout = timeout;
    this.state = 'CLOSED';
    this.nextAttempt = 0;
  }

  async execute(fn) {
    if (this.state === 'OPEN') {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }
      this.state = 'HALF-OPEN';
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  onSuccess() {
    this.failures = 0;
    this.state = 'CLOSED';
  }

  onFailure() {
    this.failures++;
    if (this.failures >= this.threshold) {
      this.state = 'OPEN';
      this.nextAttempt = Date.now() + this.timeout;
    }
  }
}

// Usage in worker
const breaker = new CircuitBreaker();

new Worker('openai-calls', async (job) => {
  return breaker.execute(async () => {
    return openai.chat.completions.create(job.data);
  });
});</code></pre>

      <h2>4. Priority Queue Pattern</h2>

      <p>Process important jobs first while still handling lower-priority work.</p>

      <pre><code class="language-typescript">// Priority levels
const PRIORITY = {
  CRITICAL: 100,  // Processed immediately
  HIGH: 50,       // Next in line
  NORMAL: 10,     // Default
  LOW: 1          // When nothing else is pending
};

// Real-time user request (high priority)
await queue.add('generate', { prompt, userId }, {
  priority: PRIORITY.HIGH
});

// Background batch job (low priority)
await queue.add('generate', { prompt, batchId }, {
  priority: PRIORITY.LOW
});</code></pre>

      <h2>5. Retry with Exponential Backoff</h2>

      <p>Handle transient failures by retrying with increasing delays.</p>

      <pre><code class="language-typescript">// Retry delays: 1s, 2s, 4s, 8s, 16s
await queue.add('api-call', data, {
  attempts: 5,
  backoff: {
    type: 'exponential',
    delay: 1000
  }
});

// Custom backoff with jitter (prevents thundering herd)
function calculateBackoff(attempt, baseDelay = 1000) {
  const exponentialDelay = baseDelay * Math.pow(2, attempt);
  const jitter = Math.random() * 1000;
  return exponentialDelay + jitter;
}</code></pre>

      <h2>6. Dead Letter Queue (DLQ) Pattern</h2>

      <p>Capture failed jobs for investigation and reprocessing.</p>

      <pre><code class="language-typescript">// Jobs move to DLQ after max attempts
await queue.add('process', data, {
  attempts: 3
});

// Monitor DLQ
const failedJobs = await queue.getDlq(100);

for (const job of failedJobs) {
  console.log(`Failed job ${job.id}:`, job.failedReason);

  // Decide action based on error
  if (job.failedReason.includes('rate limit')) {
    // Retry rate-limited jobs
    await queue.retryDlq(job.id);
  } else if (job.failedReason.includes('invalid')) {
    // Log and skip invalid jobs
    await logToSlack(`Invalid job: ${job.id}`);
  }
}

// Alert on DLQ growth
if (failedJobs.length > 100) {
  await sendAlert('DLQ has over 100 jobs!');
}</code></pre>

      <h2>7. Idempotency Pattern</h2>

      <p>Ensure jobs can be safely retried without side effects.</p>

      <pre><code class="language-typescript">// Use custom job ID for idempotency
await queue.add('charge', { userId, amount }, {
  jobId: `charge-${userId}-${orderId}`  // Unique per operation
});

// Worker checks idempotency
new Worker('payments', async (job) => {
  // Check if already processed
  const existing = await db.payments.findOne({
    idempotencyKey: job.id
  });

  if (existing) {
    return existing.result; // Return cached result
  }

  // Process and store with idempotency key
  const result = await processPayment(job.data);
  await db.payments.insert({
    idempotencyKey: job.id,
    result
  });

  return result;
});</code></pre>

      <h2>8. Scheduled Job Pattern</h2>

      <p>Run jobs at specific times using cron expressions.</p>

      <pre><code class="language-typescript">// Daily report at 9 AM
await queue.addCron('daily-report', {
  queue: 'reports',
  schedule: '0 9 * * *',
  data: { type: 'daily' }
});

// Hourly model retraining
await queue.addCron('retrain-model', {
  queue: 'ml-training',
  schedule: '0 * * * *',
  data: { modelId: 'recommendations' }
});

// Every 5 minutes - cache refresh
await queue.addCron('refresh-cache', {
  queue: 'maintenance',
  schedule: '*/5 * * * *',
  data: { cache: 'embeddings' }
});</code></pre>

      <h2>9. Batch Processing Pattern</h2>

      <p>Group multiple items into a single job for efficiency.</p>

      <pre><code class="language-typescript">// Instead of 1000 individual jobs...
const BATCH_SIZE = 100;
const batches = [];

for (let i = 0; i < items.length; i += BATCH_SIZE) {
  batches.push(items.slice(i, i + BATCH_SIZE));
}

// Create 10 batch jobs instead
for (const batch of batches) {
  await queue.add('process-batch', {
    items: batch
  });
}

// Worker processes batch efficiently
new Worker('embeddings', async (job) => {
  const { items } = job.data;

  // OpenAI supports batch embeddings
  const response = await openai.embeddings.create({
    input: items.map(i => i.text),
    model: 'text-embedding-3-small'
  });

  return response.data;
});</code></pre>

      <h2>Choosing the Right Pattern</h2>

      <table>
        <thead>
          <tr>
            <th>Scenario</th>
            <th>Pattern</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Processing many items independently</td>
            <td>Fan-Out</td>
          </tr>
          <tr>
            <td>Multi-step workflow with rollback</td>
            <td>Saga</td>
          </tr>
          <tr>
            <td>Unstable external API</td>
            <td>Circuit Breaker</td>
          </tr>
          <tr>
            <td>User-facing vs batch jobs</td>
            <td>Priority Queue</td>
          </tr>
          <tr>
            <td>Transient failures</td>
            <td>Exponential Backoff</td>
          </tr>
          <tr>
            <td>Debugging failures</td>
            <td>Dead Letter Queue</td>
          </tr>
          <tr>
            <td>Payment/mutation safety</td>
            <td>Idempotency</td>
          </tr>
          <tr>
            <td>Recurring tasks</td>
            <td>Scheduled Jobs</td>
          </tr>
          <tr>
            <td>High-volume processing</td>
            <td>Batch Processing</td>
          </tr>
        </tbody>
      </table>

      <h2>Conclusion</h2>

      <p>These patterns form the foundation of reliable AI applications. Start with the basics (retries, DLQ) and add complexity (sagas, circuit breakers) as your system grows. flashQ supports all these patterns out of the box.</p>

      <div class="article-cta">
        <h3>Build Reliable AI Apps</h3>
        <p>Get started with flashQ and implement these patterns today.</p>
        <a href="../docs/" class="btn btn-primary">Read the Docs â†’</a>
      </div>
    </div>
  </article>

  <footer>
    <div class="container wide">
      <a href="../" class="logo"><span>âš¡</span> flashQ</a>
      <div class="footer-links">
        <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
        <a href="https://npmjs.com/package/flashq" target="_blank">npm</a>
        <a href="../docs/">Docs</a>
        <a href="../blog/">Blog</a>
      </div>
      <div class="footer-copy">Â© <span id="year"></span> flashQ. MIT License.</div>
    </div>
  </footer>
  <script>
    const mobileMenuBtn = document.querySelector(".mobile-menu-btn");
    const mobileMenu = document.querySelector(".mobile-menu");
    document.getElementById("year").textContent = new Date().getFullYear();
    mobileMenuBtn.addEventListener("click", () => {
      mobileMenuBtn.classList.toggle("active");
      mobileMenu.classList.toggle("active");
      document.body.style.overflow = mobileMenu.classList.contains("active") ? "hidden" : "";
    });
    mobileMenu.querySelectorAll("a").forEach(link => {
      link.addEventListener("click", () => {
        mobileMenuBtn.classList.remove("active");
        mobileMenu.classList.remove("active");
        document.body.style.overflow = "";
      });
    });
  </script>
  <script>hljs.highlightAll();</script>
</body>
</html>
