<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>flashQ for Blockchain: 14 Use Cases That Replace Expensive Infrastructure - flashQ Blog</title>
  <meta name="description" content="Build self-hosted blockchain infrastructure with flashQ. Transaction relayers, NFT minting queues, airdrops, keepers, bridges, and more. Replace OpenZeppelin Defender and Gelato.">
  <meta name="keywords" content="flashq blockchain, transaction relayer, openzeppelin defender alternative, gelato alternative, nft minting queue, airdrop distribution, keeper automation, chainlink alternative, web3 infrastructure">
  <meta name="robots" content="index, follow">
  <meta name="author" content="flashQ Team">

  <meta property="og:title" content="flashQ for Blockchain: 14 Use Cases That Replace Expensive Infrastructure">
  <meta property="og:description" content="Build self-hosted blockchain infrastructure with flashQ. Transaction relayers, NFT minting, airdrops, keepers, and more.">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://flashq.dev/blog/blockchain-crypto-usecases.html">
  <meta property="og:image" content="https://flashq.dev/og-image.png">
  <meta property="og:site_name" content="flashQ">
  <meta property="article:published_time" content="2026-01-19">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="flashQ for Blockchain: 14 Use Cases That Replace Expensive Infrastructure">
  <meta name="twitter:description" content="Build self-hosted blockchain infrastructure with flashQ.">
  <meta name="twitter:image" content="https://flashq.dev/og-image.png">

  <link rel="canonical" href="https://flashq.dev/blog/blockchain-crypto-usecases.html">
  <link rel="alternate" type="application/rss+xml" title="flashQ Blog RSS Feed" href="https://flashq.dev/blog/feed.xml">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>⚡</text></svg>">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "headline": "flashQ for Blockchain: 14 Use Cases That Replace Expensive Infrastructure",
    "description": "Build self-hosted blockchain infrastructure with flashQ. Transaction relayers, NFT minting queues, airdrops, keepers, bridges, and more.",
    "datePublished": "2026-01-19",
    "author": { "@type": "Organization", "name": "flashQ" },
    "publisher": { "@type": "Organization", "name": "flashQ", "logo": { "@type": "ImageObject", "url": "https://flashq.dev/logo.png" } }
  }
  </script>

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
      { "@type": "ListItem", "position": 1, "name": "Home", "item": "https://flashq.dev" },
      { "@type": "ListItem", "position": 2, "name": "Blog", "item": "https://flashq.dev/blog/" },
      { "@type": "ListItem", "position": 3, "name": "Blockchain Use Cases", "item": "https://flashq.dev/blog/blockchain-crypto-usecases.html" }
    ]
  }
  </script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/rust.min.js"></script>
</head>
<body>
  <nav>
    <div class="container wide">
      <a href="../" class="logo"><span>⚡</span> flashQ</a>
      <div class="nav-links">
        <a href="../#features">Features</a>
        <a href="../blog/" class="active">Blog</a>
        <a href="../docs/">Docs</a>
        <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
        <button class="search-trigger" onclick="openSearch()"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>Search <span class="kbd">⌘K</span></button>
        <a href="../docs/#quickstart" class="btn btn-primary">Get Started</a>
      </div>
      <button class="mobile-menu-btn" aria-label="Menu"><span></span><span></span><span></span></button>
    </div>
  </nav>

  <div class="mobile-menu">
    <a href="../#features">Features</a><a href="../blog/">Blog</a><a href="../docs/">Docs</a>
    <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
    <a href="../docs/#quickstart" class="btn btn-primary">Get Started</a>
  </div>

  <header class="article-header header-blockchain">
    <div class="container">
      <span class="article-tag">Blockchain</span>
      <h1>flashQ for Blockchain: 14 Use Cases That Replace Expensive Infrastructure</h1>
      <div class="article-meta">
        <span>January 19, 2026</span>
        <span class="reading-time">18 min read</span>
      </div>
    </div>
  </header>

  <article class="article-content">
    <div class="container wide">
      <div class="article-layout">
        <div class="article-main">

      <p class="lead">If you've built anything in Web3, you know the pain: failed transactions, rate-limited RPC calls, stuck airdrops, and that dreaded "nonce too low" error at 3 AM. Most teams pay $500+/month for OpenZeppelin Defender or Gelato and still hit scaling walls. There's a better way.</p>

      <div class="callout callout-info">
        <div class="callout-title">Why flashQ for Blockchain?</div>
        <p>flashQ handles 1.9M jobs/sec with sub-millisecond latency. It's self-hosted, open-source, and provides everything blockchain apps need: priority queues, rate limiting, retry logic, job dependencies, and persistence. No vendor lock-in, no per-transaction fees.</p>
      </div>

      <h2 id="problem">The Hidden Infrastructure Problem in Web3</h2>

      <p>Every blockchain application eventually needs to:</p>

      <ul>
        <li><strong>Send transactions reliably</strong> (and handle failures gracefully)</li>
        <li><strong>Process events at scale</strong> (without losing any)</li>
        <li><strong>Rate-limit RPC calls</strong> (or get banned by Alchemy)</li>
        <li><strong>Coordinate complex operations</strong> (mint &#8594; transfer &#8594; notify)</li>
        <li><strong>Schedule recurring tasks</strong> (vesting releases, keeper operations)</li>
      </ul>

      <p>These aren't blockchain problems. They're <strong>queue problems</strong>. Yet most Web3 teams treat infrastructure as an afterthought.</p>

      <h2 id="feature-mapping">How flashQ Maps to Blockchain Needs</h2>

      <div class="table-responsive">
        <table>
          <thead>
            <tr>
              <th>flashQ Feature</th>
              <th>Blockchain Problem It Solves</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>Priority Queue</td><td>TX ordering, MEV, gas bidding</td></tr>
            <tr><td>Rate Limiting</td><td>RPC rate limits, anti-spam</td></tr>
            <tr><td>Retry + Backoff</td><td>Failed TX, network congestion</td></tr>
            <tr><td>Delayed Jobs</td><td>Vesting, time-locks, scheduled ops</td></tr>
            <tr><td>Job Dependencies</td><td>Multi-step TX flows, approvals</td></tr>
            <tr><td>DLQ</td><td>Failed TX investigation</td></tr>
            <tr><td>Cron</td><td>Keeper automation, oracle updates</td></tr>
            <tr><td>Batch Operations</td><td>Airdrops, mass minting</td></tr>
            <tr><td>Progress Tracking</td><td>Long-running operations</td></tr>
            <tr><td>Persistence</td><td>Crash recovery, audit trail</td></tr>
          </tbody>
        </table>
      </div>

      <h2 id="use-case-1">1. Transaction Relayer</h2>

      <p><strong>The problem:</strong> OpenZeppelin Defender costs $500+/month and still has scaling limits. Gelato charges per execution. Both create vendor lock-in.</p>

      <p><strong>The solution:</strong> Build your own relayer with flashQ as the backbone.</p>

      <pre><code class="language-typescript">// Submit transaction to queue
await flashq.push('relayer:submit', {
  to: contractAddress,
  data: encodedFunctionCall,
  value: 0,
  chainId: 1,
  gasStrategy: 'aggressive'
}, {
  priority: isUrgent ? 1000 : 100,
  maxAttempts: 5,
  backoff: 2000,
  timeout: 60000,
  uniqueKey: `tx:${idempotencyKey}`
});

// Worker handles signing, nonce management, submission
// Automatic retry on revert, gas estimation, etc.</code></pre>

      <p><strong>Why flashQ:</strong></p>
      <ul>
        <li>Retry logic handles network failures and reverts</li>
        <li>Priority ensures critical transactions execute first</li>
        <li>Unique keys prevent duplicate submissions</li>
        <li>DLQ captures failed transactions for investigation</li>
        <li>10-100x cheaper than managed solutions</li>
      </ul>

      <h2 id="use-case-2">2. NFT Minting Queue</h2>

      <p><strong>The problem:</strong> High-demand mints crash servers, create gas wars, and frustrate users with failed transactions.</p>

      <p><strong>The solution:</strong> Queue-based minting with fairness and rate limiting.</p>

      <pre><code class="language-typescript">// User requests mint
await flashq.push('nft:mint', {
  wallet: userAddress,
  quantity: 2,
  proof: merkleProof
}, {
  uniqueKey: `mint:${userAddress}`,  // One request per wallet
  priority: requestTimestamp,         // FIFO fairness
  maxAttempts: 5,
  timeout: 120000
});

// Rate limit to prevent gas wars
await flashq.setRateLimit('nft:mint', {
  max: 10,      // 10 mints per second
  window: 1000
});

// Concurrency limit for gas management
await flashq.setConcurrency('nft:mint', 5);</code></pre>

      <h2 id="use-case-3">3. Airdrop Distribution</h2>

      <p><strong>The problem:</strong> Sending tokens to 50,000 wallets is slow, expensive, and error-prone. One failed transaction can derail the entire process.</p>

      <p><strong>The solution:</strong> Batch processing with progress tracking and automatic recovery.</p>

      <pre><code class="language-typescript">// Queue all recipients
for (const batch of chunk(recipients, 1000)) {
  await flashq.pushBatch('airdrop:send',
    batch.map(r => ({
      data: {
        wallet: r.address,
        amount: r.amount,
        tokenAddress: TOKEN
      },
      options: {
        uniqueKey: `airdrop:${campaignId}:${r.address}`,
        maxAttempts: 10,
        backoff: 5000
      }
    }))
  );
}

// Control spend rate
await flashq.setConcurrency('airdrop:send', 3);

// Monitor progress
const counts = await flashq.getJobCounts('airdrop:send');
console.log(`Completed: ${counts.completed}/${counts.total}`);</code></pre>

      <div class="callout callout-success">
        <div class="callout-title">Why This Works</div>
        <p>Resume after crashes (PostgreSQL persistence), progress tracking for transparency, concurrency limits control gas spending, batch operations for efficiency, DLQ captures failed sends for retry.</p>
      </div>

      <h2 id="use-case-4">4. Keeper / Automation</h2>

      <p><strong>The problem:</strong> Chainlink Automation and Gelato charge per execution. Complex conditions require custom logic.</p>

      <p><strong>The solution:</strong> Self-hosted automation with flashQ cron jobs.</p>

      <pre><code class="language-typescript">// Compound-style yield harvesting
await flashq.addCron('keeper:harvest', {
  schedule: '0 */4 * * *',  // Every 4 hours
  queue: 'keeper:execute',
  data: {
    action: 'harvest',
    vaults: ['0x...', '0x...']
  }
});

// Liquidation monitoring (every 30 seconds)
await flashq.addCron('keeper:liquidations', {
  schedule: '*/30 * * * * *',
  queue: 'keeper:execute',
  data: { action: 'checkLiquidations' }
});

// Price oracle updates
await flashq.addCron('keeper:oracle', {
  schedule: '*/5 * * * *',  // Every 5 minutes
  queue: 'keeper:execute',
  data: { action: 'updatePriceFeeds' }
});</code></pre>

      <h2 id="use-case-5">5. Arbitrage Execution</h2>

      <p><strong>The problem:</strong> Arbitrage opportunities are time-sensitive. Failed executions mean missed profits. Exchange rate limits cause rejections.</p>

      <p><strong>The solution:</strong> Priority queue with LIFO processing and built-in rate limiting.</p>

      <pre><code class="language-typescript">// Opportunity detected
await flashq.push('arb:execute', {
  type: 'cross-exchange',
  buyExchange: 'binance',
  sellExchange: 'okx',
  symbol: 'ETH/USDT',
  spread: 0.15,
  deadline: Date.now() + 2000
}, {
  priority: Math.floor(spread * 10000),  // Higher spread = higher priority
  lifo: true,      // Newest opportunities first
  timeout: 3000,   // Fast timeout
  ttl: 5000        // Expire quickly
});

// Rate limits per exchange
await flashq.setRateLimit('arb:binance', { max: 1200, window: 60000 });
await flashq.setRateLimit('arb:okx', { max: 300, window: 1000 });</code></pre>

      <h2 id="use-case-6">6. Cross-Chain Bridge</h2>

      <p><strong>The problem:</strong> Bridge operations require coordination across chains. Message delivery must be reliable. Failures need manual intervention.</p>

      <p><strong>The solution:</strong> Job dependencies for multi-step workflows.</p>

      <pre><code class="language-typescript">// Step 1: Verify on source chain
const verifyJob = await flashq.push('bridge:verify', {
  sourceChain: 'ethereum',
  txHash: sourceTxHash,
  messageHash: messageHash
});

// Step 2: Wait for confirmations
const confirmJob = await flashq.push('bridge:confirm', {
  txHash: sourceTxHash,
  requiredConfirmations: 12
}, {
  dependsOn: [verifyJob.id]
});

// Step 3: Execute on destination
const executeJob = await flashq.push('bridge:execute', {
  destChain: 'arbitrum',
  message: encodedMessage
}, {
  dependsOn: [confirmJob.id],
  maxAttempts: 10,
  timeout: 300000
});

// Wait for completion
const result = await flashq.finished(executeJob.id);</code></pre>

      <h2 id="use-case-7">7. Event Indexing</h2>

      <p><strong>The problem:</strong> Processing blockchain events at scale requires handling backpressure, retries, and parallel processing without losing data.</p>

      <p><strong>The solution:</strong> Event-driven pipeline with flashQ.</p>

      <pre><code class="language-typescript">// Webhook from Alchemy/QuickNode
app.post('/webhook/events', async (req, res) => {
  const events = req.body.events;

  await flashq.pushBatch('indexer:process',
    events.map(e => ({
      data: {
        blockNumber: e.blockNumber,
        txHash: e.transactionHash,
        logIndex: e.logIndex,
        event: e.decoded
      },
      options: {
        priority: e.blockNumber,  // Process in order
        uniqueKey: `${e.transactionHash}:${e.logIndex}`
      }
    }))
  );

  res.status(200).send('OK');
});

// Workers process events in parallel
// Database writes, notifications, analytics, etc.</code></pre>

      <h2 id="use-case-8">8. Oracle Price Feeds</h2>

      <pre><code class="language-typescript">// Multi-source price aggregation
await flashq.pushBatch('oracle:fetch', [
  { data: { source: 'binance', pair: 'ETH/USD' } },
  { data: { source: 'coinbase', pair: 'ETH/USD' } },
  { data: { source: 'kraken', pair: 'ETH/USD' } }
]);

// Aggregate and push on-chain
await flashq.push('oracle:update', {
  pair: 'ETH/USD'
}, {
  dependsOn: [job1.id, job2.id, job3.id],
  delay: 5000  // Wait for all sources
});</code></pre>

      <h2 id="use-case-9">9. DEX Order Routing</h2>

      <pre><code class="language-typescript">// Smart order routing - split across DEXes
const routes = calculateOptimalRoutes(order);

await flashq.pushBatch('dex:execute',
  routes.map(route => ({
    data: {
      dex: route.dex,
      path: route.path,
      amountIn: route.amountIn,
      minAmountOut: route.minAmountOut
    },
    options: {
      priority: route.expectedOutput,
      timeout: 30000,
      maxAttempts: 3
    }
  }))
);</code></pre>

      <h2 id="use-case-10">10. Liquidation Bots</h2>

      <pre><code class="language-typescript">// Monitor positions cron (every 10 seconds)
await flashq.addCron('liquidation:monitor', {
  schedule: '*/10 * * * * *',
  queue: 'liquidation:check',
  data: { action: 'scanPositions' }
});

// When position is at risk
await flashq.push('liquidation:execute', {
  protocol: 'aave',
  positionId: position.id,
  collateral: position.collateral,
  debt: position.debt,
  healthFactor: position.healthFactor
}, {
  priority: Math.floor((1 / position.healthFactor) * 10000), // Lower health = higher priority
  timeout: 5000,
  maxAttempts: 3
});</code></pre>

      <h2 id="use-case-11">11. Token Vesting</h2>

      <pre><code class="language-typescript">// Monthly vesting releases
await flashq.addCron('vesting:release', {
  schedule: '0 0 1 * *',  // 1st of each month
  queue: 'vesting:process',
  data: { vestingContract: '0x...' }
});

// Process vesting release
async function processVesting(job) {
  const { vestingContract } = job.data;
  const beneficiaries = await getBeneficiaries(vestingContract);

  await flashq.pushBatch('vesting:transfer',
    beneficiaries.map(b => ({
      data: {
        recipient: b.address,
        amount: b.vestedAmount
      },
      options: {
        uniqueKey: `vesting:${b.address}:${Date.now()}`,
        maxAttempts: 5
      }
    }))
  );
}</code></pre>

      <h2 id="use-case-12">12. DAO Governance</h2>

      <pre><code class="language-typescript">// Timelock execution queue
await flashq.push('dao:execute', {
  proposalId: 42,
  targets: ['0x...'],
  calldatas: ['0x...']
}, {
  delay: 48 * 60 * 60 * 1000,  // 48h timelock
  uniqueKey: `proposal:42`
});

// Queue proposal notifications
await flashq.push('dao:notify', {
  proposalId: 42,
  event: 'queued',
  channels: ['discord', 'telegram', 'email']
});</code></pre>

      <h2 id="use-case-13">13. Webhook Processing (Alchemy/QuickNode)</h2>

      <pre><code class="language-typescript">// Receive webhooks with backpressure handling
app.post('/webhook/alchemy', async (req, res) => {
  // Immediately acknowledge
  res.status(200).send('OK');

  // Queue for processing
  await flashq.push('webhook:process', {
    source: 'alchemy',
    payload: req.body,
    receivedAt: Date.now()
  }, {
    priority: req.body.blockNumber || 0
  });
});

// Rate limit webhook processing
await flashq.setRateLimit('webhook:process', {
  max: 100,
  window: 1000
});</code></pre>

      <h2 id="use-case-14">14. Wallet Notifications</h2>

      <pre><code class="language-typescript">// Fan-out notifications on large transfer
await flashq.push('notify:large-transfer', {
  wallet: '0x...',
  amount: '1000000',
  token: 'USDC',
  txHash: '0x...'
});

// Worker handles multi-channel delivery
async function processNotification(job) {
  const { wallet, amount, token } = job.data;
  const user = await getUserByWallet(wallet);

  const channels = user.notificationSettings;

  await flashq.pushBatch('notify:deliver',
    channels.map(channel => ({
      data: {
        channel: channel.type,
        destination: channel.address,
        message: `Large transfer: ${amount} ${token}`
      },
      options: {
        maxAttempts: 3,
        backoff: 1000
      }
    }))
  );
}</code></pre>

      <h2 id="comparison">Comparison: flashQ vs. Alternatives</h2>

      <div class="table-responsive">
        <table>
          <thead>
            <tr>
              <th>Feature</th>
              <th>flashQ</th>
              <th>OZ Defender</th>
              <th>Gelato</th>
              <th>Redis + BullMQ</th>
            </tr>
          </thead>
          <tbody>
            <tr><td><strong>Throughput</strong></td><td>1.9M/sec</td><td>Limited</td><td>Limited</td><td>~50K/sec</td></tr>
            <tr><td><strong>Self-hosted</strong></td><td>Yes</td><td>No</td><td>No</td><td>Yes</td></tr>
            <tr><td><strong>Cost</strong></td><td>Infra only</td><td>$500+/mo</td><td>Per execution</td><td>Infra</td></tr>
            <tr><td><strong>Priority queues</strong></td><td>Native</td><td>Limited</td><td>No</td><td>Yes</td></tr>
            <tr><td><strong>Rate limiting</strong></td><td>Built-in</td><td>Manual</td><td>N/A</td><td>Manual</td></tr>
            <tr><td><strong>Job dependencies</strong></td><td>Native</td><td>No</td><td>No</td><td>Yes</td></tr>
            <tr><td><strong>Cron jobs</strong></td><td>6-field</td><td>Limited</td><td>Yes</td><td>Plugin</td></tr>
            <tr><td><strong>Clustering/HA</strong></td><td>Native</td><td>Yes</td><td>Yes</td><td>Complex</td></tr>
            <tr><td><strong>Vendor lock-in</strong></td><td>None</td><td>High</td><td>High</td><td>Low</td></tr>
          </tbody>
        </table>
      </div>

      <h2 id="architecture">Architecture: flashQ Blockchain Layer</h2>

      <pre><code class="language-text">flashq-blockchain/
├── engine/                 # Core flashQ server
├── blockchain/
│   ├── src/
│   │   ├── relayer/        # Transaction submission
│   │   │   ├── nonce.rs    # Nonce management
│   │   │   ├── gas.rs      # Gas estimation & EIP-1559
│   │   │   └── signer.rs   # Key management (KMS, Vault)
│   │   ├── indexer/        # Event processing
│   │   ├── keeper/         # Automation tasks
│   │   ├── oracle/         # Price feeds
│   │   └── chains/         # Multi-chain configs
│   │       ├── ethereum.rs
│   │       ├── polygon.rs
│   │       ├── arbitrum.rs
│   │       └── base.rs
│   └── Cargo.toml
└── sdk/
    └── typescript/
        └── src/
            └── blockchain.ts   # Blockchain-specific SDK</code></pre>

      <h2 id="getting-started">Getting Started</h2>

      <pre><code class="language-bash"># Quick start with Docker
docker run -p 6789:6789 -p 6790:6790 flashq/flashq

# Or with PostgreSQL persistence
docker-compose up -d</code></pre>

      <pre><code class="language-typescript">import { FlashQ } from 'flashq-sdk';

const client = new FlashQ({ host: 'localhost', port: 6789 });
await client.connect();

// Push your first blockchain job
await client.push('relayer:submit', {
  to: '0x...',
  data: '0x...',
  chainId: 1
}, {
  priority: 100,
  maxAttempts: 5,
  backoff: 2000
});

// Process it
const job = await client.pull('relayer:submit');
// Sign and submit transaction...
await client.ack(job.id, { txHash: '0x...' });</code></pre>

      <h2 id="conclusion">Conclusion</h2>

      <p>Blockchain applications have unique infrastructure needs: reliability, speed, and cost efficiency. Most teams either overpay for managed solutions or build fragile custom systems.</p>

      <p>flashQ offers a third path: <strong>production-grade infrastructure you own and control</strong>.</p>

      <p>Whether you're building a transaction relayer, NFT platform, DeFi protocol, or bridge—the queue is the foundation. Make it solid.</p>

      <div class="callout callout-success">
        <div class="callout-title">Cost Comparison</div>
        <p><strong>OpenZeppelin Defender:</strong> $500-2000/month<br>
        <strong>Gelato:</strong> $0.01-0.10 per execution<br>
        <strong>flashQ:</strong> ~$20/month (small VPS) for unlimited executions</p>
      </div>

      <div class="article-cta">
        <h3>Build Your Blockchain Infrastructure</h3>
        <p>Start building self-hosted blockchain infrastructure with flashQ today.</p>
        <a href="../docs/#quickstart" class="btn btn-primary">Get Started</a>
        <a href="https://github.com/egeominotti/flashq" class="btn btn-secondary" target="_blank">View on GitHub</a>
      </div>

        </div>

        <aside class="toc-sidebar">
          <nav class="toc">
            <div class="toc-title">On this page</div>
            <ul class="toc-list">
              <li><a href="#problem">The Problem</a></li>
              <li><a href="#feature-mapping">Feature Mapping</a></li>
              <li><a href="#use-case-1">1. Transaction Relayer</a></li>
              <li><a href="#use-case-2">2. NFT Minting Queue</a></li>
              <li><a href="#use-case-3">3. Airdrop Distribution</a></li>
              <li><a href="#use-case-4">4. Keeper/Automation</a></li>
              <li><a href="#use-case-5">5. Arbitrage Execution</a></li>
              <li><a href="#use-case-6">6. Cross-Chain Bridge</a></li>
              <li><a href="#use-case-7">7. Event Indexing</a></li>
              <li><a href="#use-case-8">8. Oracle Price Feeds</a></li>
              <li><a href="#use-case-9">9. DEX Order Routing</a></li>
              <li><a href="#use-case-10">10. Liquidation Bots</a></li>
              <li><a href="#use-case-11">11. Token Vesting</a></li>
              <li><a href="#use-case-12">12. DAO Governance</a></li>
              <li><a href="#use-case-13">13. Webhook Processing</a></li>
              <li><a href="#use-case-14">14. Wallet Notifications</a></li>
              <li><a href="#comparison">Comparison</a></li>
              <li><a href="#architecture">Architecture</a></li>
              <li><a href="#getting-started">Getting Started</a></li>
              <li><a href="#conclusion">Conclusion</a></li>
            </ul>
          </nav>
        </aside>
      </div>
    </div>
  </article>

  <footer>
    <div class="container wide">
      <a href="../" class="logo"><span>⚡</span> flashQ</a>
      <div class="footer-links">
        <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
        <a href="https://npmjs.com/package/flashq" target="_blank">npm</a>
        <a href="../docs/">Docs</a>
        <a href="../blog/">Blog</a>
      </div>
      <div class="footer-copy">&copy; <span id="year"></span> flashQ. MIT License.</div>
    </div>
  </footer>

  <div class="search-overlay" id="searchOverlay" onclick="closeSearch(event)">
    <div class="search-modal" onclick="event.stopPropagation()">
      <div class="search-input-wrapper">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>
        <input type="text" class="search-modal-input" id="searchInput" placeholder="Search...">
        <span class="search-shortcut">ESC</span>
      </div>
      <div class="search-results" id="searchResults"></div>
    </div>
  </div>

  <script>
    document.getElementById("year").textContent = new Date().getFullYear();
    const mobileMenuBtn = document.querySelector(".mobile-menu-btn");
    const mobileMenu = document.querySelector(".mobile-menu");
    mobileMenuBtn.addEventListener("click", () => { mobileMenuBtn.classList.toggle("active"); mobileMenu.classList.toggle("active"); });
    const tocLinks = document.querySelectorAll('.toc-list a');
    const headings = document.querySelectorAll('h2[id]');
    function updateTocActive() { let current = ''; headings.forEach(h => { if (window.scrollY >= h.offsetTop - 120) current = h.id; }); tocLinks.forEach(l => l.classList.toggle('active', l.getAttribute('href') === '#' + current)); }
    window.addEventListener('scroll', updateTocActive); updateTocActive();
    function openSearch() { document.getElementById('searchOverlay').classList.add('active'); document.getElementById('searchInput').focus(); }
    function closeSearch(e) { if (e?.target === document.getElementById('searchOverlay')) document.getElementById('searchOverlay').classList.remove('active'); }
    document.addEventListener('keydown', e => { if ((e.metaKey||e.ctrlKey) && e.key==='k') { e.preventDefault(); openSearch(); } if (e.key==='Escape') closeSearch({target:document.getElementById('searchOverlay')}); });
  </script>
  <script>hljs.highlightAll();</script>
</body>
</html>
