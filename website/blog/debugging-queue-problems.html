<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debugging flashQ: Logs, Metrics, and Troubleshooting Guide - flashQ Blog</title>
  <meta name="description" content="Complete troubleshooting guide for flashQ job queues. Learn to diagnose stuck jobs, memory issues, connection problems, and performance bottlenecks with logs and metrics.">
  <meta name="keywords" content="flashq debugging, job queue troubleshooting, queue problems, stuck jobs, dlq debugging, flashq logs, job queue monitoring">
  <meta name="robots" content="index, follow">
  <meta name="author" content="flashQ Team">

  <meta property="og:title" content="Debugging flashQ: Logs, Metrics, and Troubleshooting Guide">
  <meta property="og:description" content="Complete troubleshooting guide for flashQ. Diagnose stuck jobs, memory issues, and performance bottlenecks.">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://flashq.dev/blog/debugging-queue-problems.html">
  <meta property="og:image" content="https://flashq.dev/og-image.png">
  <meta property="og:site_name" content="flashQ">
  <meta property="article:published_time" content="2026-01-19">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Debugging flashQ: Complete Troubleshooting Guide">
  <meta name="twitter:description" content="Diagnose stuck jobs, memory issues, and performance bottlenecks.">
  <meta name="twitter:image" content="https://flashq.dev/og-image.png">

  <link rel="canonical" href="https://flashq.dev/blog/debugging-queue-problems.html">
  <link rel="alternate" type="application/rss+xml" title="flashQ Blog RSS Feed" href="https://flashq.dev/blog/feed.xml">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚ö°</text></svg>">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "headline": "Debugging flashQ: Logs, Metrics, and Troubleshooting Guide",
    "description": "Complete troubleshooting guide for flashQ job queues with common problems and solutions.",
    "datePublished": "2026-01-19",
    "dateModified": "2026-01-19",
    "author": { "@type": "Organization", "name": "flashQ", "url": "https://flashq.dev" },
    "publisher": { "@type": "Organization", "name": "flashQ", "url": "https://flashq.dev" },
    "mainEntityOfPage": { "@type": "WebPage", "@id": "https://flashq.dev/blog/debugging-queue-problems.html" },
    "image": "https://flashq.dev/og-image.png"
  }
  </script>

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
      { "@type": "ListItem", "position": 1, "name": "Home", "item": "https://flashq.dev" },
      { "@type": "ListItem", "position": 2, "name": "Blog", "item": "https://flashq.dev/blog/" },
      { "@type": "ListItem", "position": 3, "name": "Debugging Queue Problems", "item": "https://flashq.dev/blog/debugging-queue-problems.html" }
    ]
  }
  </script>
</head>
<body>
  <nav>
    <div class="container wide">
      <a href="../" class="logo"><span>‚ö°</span> flashQ</a>
      <div class="nav-links">
        <a href="../#features">Features</a>
        <a href="../blog/" class="active">Blog</a>
        <a href="../docs/">Docs</a>
        <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
        <a href="../docs/#quickstart" class="btn btn-primary">Get Started</a>
      </div>
      <button class="mobile-menu-btn" aria-label="Menu"><span></span><span></span><span></span></button>
    </div>
  </nav>

  <div class="mobile-menu">
    <a href="../#features">Features</a>
    <a href="../blog/">Blog</a>
    <a href="../docs/">Docs</a>
    <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
    <a href="../docs/#quickstart" class="btn btn-primary">Get Started</a>
  </div>

  <article class="blog-post">
    <div class="container narrow">
      <header class="post-header">
        <div class="post-meta">
          <span class="post-tag">Troubleshooting</span>
          <time datetime="2026-01-19">January 19, 2026</time>
          <span class="reading-time">12 min read</span>
        </div>
        <h1>Debugging flashQ: Logs, Metrics, and Troubleshooting Guide</h1>
        <p class="post-subtitle">Something's wrong with your queue? This guide covers the most common problems and how to diagnose them using logs, metrics, and built-in tools.</p>
      </header>

      <div class="post-content">
        <nav class="toc">
          <h3>Quick Navigation</h3>
          <ul>
            <li><a href="#diagnostic-tools">Diagnostic Tools</a></li>
            <li><a href="#stuck-jobs">Problem: Jobs Stuck in Processing</a></li>
            <li><a href="#dlq-filling">Problem: DLQ Filling Up</a></li>
            <li><a href="#slow-processing">Problem: Slow Processing</a></li>
            <li><a href="#connection-issues">Problem: Connection Issues</a></li>
            <li><a href="#memory-issues">Problem: Memory Issues</a></li>
            <li><a href="#missing-jobs">Problem: Missing Jobs</a></li>
          </ul>
        </nav>

        <h2 id="diagnostic-tools">Diagnostic Tools Overview</h2>

        <h3>1. HTTP API Endpoints</h3>
        <p>The HTTP API provides essential debugging endpoints:</p>

        <pre><code class="language-bash"># Health check - basic server status
curl http://localhost:6790/health

# Detailed statistics
curl http://localhost:6790/stats

# Prometheus metrics
curl http://localhost:6790/metrics/prometheus

# List all queues
curl http://localhost:6790/queues

# Get specific queue info
curl http://localhost:6790/queue/my-queue/stats</code></pre>

        <h3>2. SDK Debugging Methods</h3>
        <pre><code class="language-typescript">import { FlashQ } from 'flashq';

const client = new FlashQ({ host: 'localhost', port: 6789 });

// Get server-wide statistics
const stats = await client.stats();
console.log('Server Stats:', JSON.stringify(stats, null, 2));

// Get metrics with history
const metrics = await client.metrics();
console.log('Metrics:', metrics);

// Get job counts by state
const counts = await client.getJobCounts('my-queue');
console.log('Job Counts:', counts);
// { waiting: 150, active: 10, completed: 5000, failed: 23, delayed: 50 }

// List jobs in a specific state
const failedJobs = await client.getJobs('my-queue', 'failed', 100);
failedJobs.forEach(job => {
  console.log(`Job ${job.id}: ${job.error}`);
});

// Get a specific job's details
const job = await client.getJob(jobId);
console.log('Job State:', job.state);
console.log('Job Data:', job.data);
console.log('Job Attempts:', job.attempts);
console.log('Job Error:', job.error);</code></pre>

        <h3>3. Useful Debugging Script</h3>
        <pre><code class="language-typescript">// debug-queue.ts - Save this for quick diagnostics
import { FlashQ } from 'flashq';

async function diagnose(queueName: string) {
  const client = new FlashQ({ host: 'localhost', port: 6789 });
  await client.connect();

  console.log('\n=== Queue Diagnostics ===\n');

  // 1. Job counts
  const counts = await client.getJobCounts(queueName);
  console.log('üìä Job Counts:');
  console.log(`   Waiting:   ${counts.waiting}`);
  console.log(`   Active:    ${counts.active}`);
  console.log(`   Completed: ${counts.completed}`);
  console.log(`   Failed:    ${counts.failed}`);
  console.log(`   Delayed:   ${counts.delayed}`);

  // 2. Check for stuck jobs (active for too long)
  const activeJobs = await client.getJobs(queueName, 'active', 10);
  console.log('\n‚è≥ Active Jobs:');
  activeJobs.forEach(job => {
    const age = Date.now() - job.processedAt;
    const status = age > 60000 ? '‚ö†Ô∏è POSSIBLY STUCK' : '‚úÖ OK';
    console.log(`   Job ${job.id}: ${Math.round(age/1000)}s old ${status}`);
  });

  // 3. Recent failures
  const failedJobs = await client.getJobs(queueName, 'failed', 5);
  console.log('\n‚ùå Recent Failures:');
  failedJobs.forEach(job => {
    console.log(`   Job ${job.id}: ${job.error?.substring(0, 80)}...`);
  });

  // 4. DLQ check
  const dlq = await client.getDlq(queueName, 5);
  console.log(`\n‚ò†Ô∏è Dead Letter Queue: ${dlq.length} jobs`);
  dlq.forEach(job => {
    console.log(`   Job ${job.id}: ${job.attempts} attempts, last error: ${job.error?.substring(0, 50)}`);
  });

  // 5. Queue paused?
  const isPaused = await client.isPaused(queueName);
  console.log(`\n‚è∏Ô∏è Queue Paused: ${isPaused ? 'YES ‚ö†Ô∏è' : 'No'}`);

  await client.close();
}

// Run: bun run debug-queue.ts my-queue
diagnose(process.argv[2] || 'default');</code></pre>

        <h2 id="stuck-jobs">Problem: Jobs Stuck in Processing</h2>

        <div class="problem-box">
          <h4>Symptoms</h4>
          <ul>
            <li>Jobs show as "active" but never complete</li>
            <li><code>getJobCounts</code> shows high <code>active</code> count that doesn't decrease</li>
            <li>Workers appear idle but jobs aren't being processed</li>
          </ul>
        </div>

        <h3>Diagnosis Steps</h3>

        <pre><code class="language-typescript">// 1. Check how long jobs have been active
const activeJobs = await client.getJobs('my-queue', 'active', 100);

activeJobs.forEach(job => {
  const activeTime = Date.now() - job.processedAt;
  if (activeTime > 60000) { // More than 1 minute
    console.log(`‚ö†Ô∏è Job ${job.id} stuck for ${Math.round(activeTime/1000)}s`);
    console.log(`   Worker: ${job.workerId}`);
    console.log(`   Data: ${JSON.stringify(job.data).substring(0, 100)}`);
  }
});</code></pre>

        <h3>Common Causes & Solutions</h3>

        <h4>1. Worker Crashed Without ACK</h4>
        <pre><code class="language-typescript">// Problem: Worker died before acknowledging
// Solution: flashQ auto-recovers after stall_timeout

// Set appropriate stall timeout when pushing jobs
await client.push('my-queue', data, {
  stall_timeout: 30000,  // 30 seconds
  timeout: 60000         // 60 second processing timeout
});

// Jobs will automatically return to queue after timeout</code></pre>

        <h4>2. Infinite Loop in Processor</h4>
        <pre><code class="language-typescript">// Problem: Processor never returns
// BAD
const worker = new Worker('my-queue', async (job) => {
  while (true) {  // Infinite loop!
    await doSomething();
  }
});

// GOOD - Always have exit conditions
const worker = new Worker('my-queue', async (job) => {
  const maxIterations = 1000;
  for (let i = 0; i < maxIterations; i++) {
    const done = await doSomething();
    if (done) break;
  }
});</code></pre>

        <h4>3. Unhandled Promise</h4>
        <pre><code class="language-typescript">// Problem: Async operation without await
// BAD
const worker = new Worker('my-queue', async (job) => {
  fetchData(job.data.url);  // Missing await!
  return 'done';  // Returns immediately
});

// GOOD
const worker = new Worker('my-queue', async (job) => {
  await fetchData(job.data.url);
  return 'done';
});</code></pre>

        <h4>4. Manual Recovery</h4>
        <pre><code class="language-typescript">// Force-fail stuck jobs to return them to queue
const activeJobs = await client.getJobs('my-queue', 'active', 100);

for (const job of activeJobs) {
  const activeTime = Date.now() - job.processedAt;
  if (activeTime > 300000) { // Stuck for 5+ minutes
    console.log(`Force-failing stuck job ${job.id}`);
    await client.fail(job.id, 'Manual recovery: job was stuck');
  }
}</code></pre>

        <h2 id="dlq-filling">Problem: DLQ Filling Up</h2>

        <div class="problem-box">
          <h4>Symptoms</h4>
          <ul>
            <li>Many jobs in Dead Letter Queue</li>
            <li>Same errors repeating</li>
            <li>Jobs failing after max retries</li>
          </ul>
        </div>

        <h3>Diagnosis</h3>

        <pre><code class="language-typescript">// Analyze DLQ errors
const dlqJobs = await client.getDlq('my-queue', 100);

// Group by error type
const errorGroups = {};
dlqJobs.forEach(job => {
  const errorType = job.error?.split(':')[0] || 'Unknown';
  errorGroups[errorType] = (errorGroups[errorType] || 0) + 1;
});

console.log('Error Distribution:');
Object.entries(errorGroups)
  .sort((a, b) => b[1] - a[1])
  .forEach(([error, count]) => {
    console.log(`  ${count}x ${error}`);
  });</code></pre>

        <h3>Common Causes & Solutions</h3>

        <h4>1. External API Failures</h4>
        <pre><code class="language-typescript">// Problem: Third-party API returns errors
// Solution: Add circuit breaker and better retry logic

import CircuitBreaker from 'opossum';

const breaker = new CircuitBreaker(callExternalAPI, {
  timeout: 10000,
  errorThresholdPercentage: 50,
  resetTimeout: 30000
});

const worker = new Worker('api-calls', async (job) => {
  try {
    return await breaker.fire(job.data);
  } catch (error) {
    if (breaker.opened) {
      // Circuit is open, fail fast and retry later
      throw new Error('Circuit breaker open, will retry');
    }
    throw error;
  }
});</code></pre>

        <h4>2. Invalid Job Data</h4>
        <pre><code class="language-typescript">// Problem: Jobs have bad data that will never succeed
// Solution: Validate before processing, discard invalid

const worker = new Worker('process', async (job) => {
  // Validate first
  if (!job.data.userId || !job.data.action) {
    // Don't retry invalid jobs - discard them
    await client.discard(job.id);
    console.log(`Discarded invalid job ${job.id}`);
    return;
  }

  // Process valid jobs
  await processJob(job.data);
});</code></pre>

        <h4>3. Retry DLQ Jobs After Fix</h4>
        <pre><code class="language-typescript">// After fixing the root cause, retry DLQ jobs
const retried = await client.retryDlq('my-queue');
console.log(`Retried ${retried} jobs from DLQ`);

// Or retry specific jobs
const dlqJobs = await client.getDlq('my-queue', 100);
for (const job of dlqJobs) {
  if (job.error?.includes('API rate limit')) {
    await client.retryDlq('my-queue', job.id);
  }
}</code></pre>

        <h2 id="slow-processing">Problem: Slow Processing</h2>

        <div class="problem-box">
          <h4>Symptoms</h4>
          <ul>
            <li>Queue backlog growing</li>
            <li>High latency between push and processing</li>
            <li>Throughput lower than expected</li>
          </ul>
        </div>

        <h3>Diagnosis</h3>

        <pre><code class="language-typescript">// Check queue depth and processing rate
const stats = await client.stats();
console.log('Queue depths:', stats.queues);

// Monitor throughput over time
const metrics = await client.metrics();
console.log('Throughput history:', metrics.throughput);

// Check if rate limiting is active
// Look for rate limit in stats</code></pre>

        <h3>Common Causes & Solutions</h3>

        <h4>1. Low Worker Concurrency</h4>
        <pre><code class="language-typescript">// Problem: Only processing one job at a time
// Solution: Increase concurrency

// Before
const worker = new Worker('my-queue', processor);  // Default: 1

// After - for I/O bound tasks
const worker = new Worker('my-queue', processor, {
  concurrency: 20  // Process 20 jobs concurrently
});</code></pre>

        <h4>2. Rate Limiting Too Strict</h4>
        <pre><code class="language-typescript">// Check current rate limit
// If processing is slow, rate limit might be too low

// Increase rate limit
await client.setRateLimit('my-queue', {
  max: 100,      // 100 jobs
  window: 1000   // per second
});

// Or clear rate limit entirely for testing
await client.clearRateLimit('my-queue');</code></pre>

        <h4>3. Large Payloads</h4>
        <pre><code class="language-typescript">// Problem: Serializing large payloads is slow
// Solution: Use references instead of inline data

// Before - slow
await client.push('process', {
  document: base64EncodedDocument  // 5MB inline
});

// After - fast
await client.push('process', {
  documentUrl: await uploadToS3(document)  // URL reference
});</code></pre>

        <h4>4. Enable Binary Protocol</h4>
        <pre><code class="language-typescript">// 40% faster serialization with MessagePack
const client = new FlashQ({
  host: 'localhost',
  port: 6789,
  useBinary: true
});</code></pre>

        <h2 id="connection-issues">Problem: Connection Issues</h2>

        <div class="problem-box">
          <h4>Symptoms</h4>
          <ul>
            <li>Connection timeouts</li>
            <li>"Connection refused" errors</li>
            <li>Intermittent disconnects</li>
          </ul>
        </div>

        <h3>Diagnosis</h3>

        <pre><code class="language-bash"># Check if server is running
curl http://localhost:6790/health

# Check port is open
nc -zv localhost 6789

# Check server logs
docker logs flashq-server 2>&1 | tail -100</code></pre>

        <h3>Common Causes & Solutions</h3>

        <h4>1. Connection Pool Exhausted</h4>
        <pre><code class="language-typescript">// Problem: Too many connections
// Solution: Reuse client instances

// BAD - Creates new connection per request
app.post('/job', async (req, res) => {
  const client = new FlashQ({ host: 'localhost' });
  await client.connect();
  await client.push('queue', req.body);
  await client.close();  // Connection churn!
});

// GOOD - Singleton client
const client = new FlashQ({ host: 'localhost' });
await client.connect();

app.post('/job', async (req, res) => {
  await client.push('queue', req.body);  // Reuses connection
});</code></pre>

        <h4>2. Network Timeouts</h4>
        <pre><code class="language-typescript">// Increase timeout for slow networks
const client = new FlashQ({
  host: 'remote-server.com',
  port: 6789,
  timeout: 30000  // 30 second timeout
});</code></pre>

        <h4>3. Authentication Failures</h4>
        <pre><code class="language-typescript">// Check token is correct
const client = new FlashQ({
  host: 'localhost',
  port: 6789,
  token: process.env.FLASHQ_TOKEN
});

// If connection fails, verify token matches server
// Server: AUTH_TOKENS=my-token ./flashq-server
// Client: token: 'my-token'</code></pre>

        <h2 id="memory-issues">Problem: Memory Issues</h2>

        <div class="problem-box">
          <h4>Symptoms</h4>
          <ul>
            <li>Server memory growing continuously</li>
            <li>OOM kills</li>
            <li>Slow response times</li>
          </ul>
        </div>

        <h3>Diagnosis</h3>

        <pre><code class="language-bash"># Check server memory
docker stats flashq-server

# Check completed jobs count (memory accumulation)
curl http://localhost:6790/stats | jq '.completed_jobs'</code></pre>

        <h3>Common Causes & Solutions</h3>

        <h4>1. Too Many Completed Jobs Stored</h4>
        <pre><code class="language-typescript">// Problem: Keeping too many completed job results
// Solution: Set retention limits

// Per-job retention
await client.push('my-queue', data, {
  keepCompletedAge: 3600000,  // Keep for 1 hour only
  keepCompletedCount: 100     // Or keep last 100
});

// Clean old jobs periodically
await client.clean('my-queue', 3600000, 'completed', 1000);
// Removes completed jobs older than 1 hour, max 1000</code></pre>

        <h4>2. Large Job Payloads in Memory</h4>
        <pre><code class="language-typescript">// Problem: Storing large data in jobs
// Solution: External storage

// Store in S3/Redis/DB and reference
const dataId = await storeInS3(largeData);
await client.push('process', { dataRef: dataId });</code></pre>

        <h2 id="missing-jobs">Problem: Missing Jobs</h2>

        <div class="problem-box">
          <h4>Symptoms</h4>
          <ul>
            <li>Jobs pushed but never processed</li>
            <li>getJob returns null</li>
            <li>Job IDs not found</li>
          </ul>
        </div>

        <h3>Diagnosis</h3>

        <pre><code class="language-typescript">// Check job exists and its state
const job = await client.getJob(jobId);
if (!job) {
  console.log('Job not found - may have been cleaned up');
} else {
  console.log('Job state:', job.state);
  console.log('Job queue:', job.queue);
}

// Check if job was completed and cleaned
const state = await client.getState(jobId);
console.log('State:', state);  // null if cleaned up</code></pre>

        <h3>Common Causes & Solutions</h3>

        <h4>1. Job Already Completed and Cleaned</h4>
        <pre><code class="language-typescript">// Problem: Job was processed but results were cleaned
// Solution: Increase retention if you need results longer

await client.push('my-queue', data, {
  keepCompletedAge: 86400000,  // Keep for 24 hours
});</code></pre>

        <h4>2. Job in Different Queue</h4>
        <pre><code class="language-typescript">// Check all queues for the job
const queues = await client.listQueues();
for (const queue of queues) {
  const counts = await client.getJobCounts(queue);
  console.log(`${queue}: ${JSON.stringify(counts)}`);
}</code></pre>

        <h4>3. Server Restart Without Persistence</h4>
        <pre><code class="language-bash"># Problem: Using in-memory mode
# Solution: Always use PostgreSQL in production

DATABASE_URL=postgres://user:pass@db/flashq ./flashq-server</code></pre>

        <h2>Quick Reference: Debug Commands</h2>

        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th>Problem</th>
                <th>Command</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Check server health</td>
                <td><code>curl localhost:6790/health</code></td>
              </tr>
              <tr>
                <td>View all queue stats</td>
                <td><code>curl localhost:6790/stats</code></td>
              </tr>
              <tr>
                <td>Check specific job</td>
                <td><code>client.getJob(jobId)</code></td>
              </tr>
              <tr>
                <td>View DLQ</td>
                <td><code>client.getDlq('queue', 100)</code></td>
              </tr>
              <tr>
                <td>Count jobs by state</td>
                <td><code>client.getJobCounts('queue')</code></td>
              </tr>
              <tr>
                <td>List stuck jobs</td>
                <td><code>client.getJobs('queue', 'active', 100)</code></td>
              </tr>
              <tr>
                <td>Check if paused</td>
                <td><code>client.isPaused('queue')</code></td>
              </tr>
              <tr>
                <td>Retry failed jobs</td>
                <td><code>client.retryDlq('queue')</code></td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="callout callout-info">
          <strong>Still Stuck?</strong> Open an issue on <a href="https://github.com/egeominotti/flashq/issues" target="_blank">GitHub</a> with your diagnostic output and we'll help you troubleshoot.
        </div>

        <h2>Related Resources</h2>
        <ul>
          <li><a href="production-checklist.html">Production Checklist</a></li>
          <li><a href="error-handling-retry-patterns.html">Error Handling & Retry Patterns</a></li>
          <li><a href="monitoring-ai-pipelines.html">Monitoring AI Pipelines</a></li>
        </ul>
      </div>

      <footer class="post-footer">
        <div class="post-tags">
          <a href="#">#debugging</a>
          <a href="#">#troubleshooting</a>
          <a href="#">#monitoring</a>
          <a href="#">#devops</a>
        </div>
      </footer>
    </div>
  </article>

  <footer class="site-footer">
    <div class="container">
      <a href="../" class="logo"><span>‚ö°</span> flashQ</a>
      <div class="footer-links">
        <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
        <a href="https://npmjs.com/package/flashq" target="_blank">npm</a>
        <a href="../docs/">Docs</a>
        <a href="../blog/">Blog</a>
      </div>
      <div class="footer-copy">¬© 2026 flashQ. MIT License.</div>
    </div>
  </footer>

  <script src="script.js"></script>
</body>
</html>
