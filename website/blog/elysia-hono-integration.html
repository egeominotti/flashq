<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>flashQ + Elysia & Hono.js: Modern Bun-Powered Background Jobs - flashQ Blog</title>
  <meta name="description" content="Learn how to integrate flashQ with Elysia and Hono.js for blazing-fast background job processing. Build production-ready APIs with Bun's lightning speed.">
  <meta name="keywords" content="elysia flashq, hono.js background jobs, bun job queue, elysia worker, hono background processing, bun queue server">
  <meta name="robots" content="index, follow">

  <meta property="og:title" content="flashQ + Elysia & Hono.js: Modern Bun-Powered Background Jobs">
  <meta property="og:description" content="Integrate flashQ with Elysia and Hono.js for blazing-fast background job processing.">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://flashq.dev/blog/elysia-hono-integration.html">
  <meta property="og:image" content="https://flashq.dev/og-image.png">
  <meta property="article:published_time" content="2026-01-19">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="flashQ + Elysia & Hono.js: Modern Bun-Powered Background Jobs">
  <meta name="twitter:description" content="Integrate flashQ with Elysia and Hono.js for blazing-fast background job processing.">
  <meta name="twitter:image" content="https://flashq.dev/og-image.png">

  <link rel="canonical" href="https://flashq.dev/blog/elysia-hono-integration.html">
  <link rel="alternate" type="application/rss+xml" title="flashQ Blog RSS Feed" href="https://flashq.dev/blog/feed.xml">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>âš¡</text></svg>">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="styles.css">

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "flashQ + Elysia & Hono.js: Modern Bun-Powered Background Jobs",
    "description": "Integrate flashQ with Elysia and Hono.js for blazing-fast background job processing.",
    "datePublished": "2026-01-19",
    "author": { "@type": "Organization", "name": "flashQ" }
  }
  </script>

  <!-- Breadcrumb Schema -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
      { "@type": "ListItem", "position": 1, "name": "Home", "item": "https://flashq.dev" },
      { "@type": "ListItem", "position": 2, "name": "Blog", "item": "https://flashq.dev/blog/" },
      { "@type": "ListItem", "position": 3, "name": "Elysia & Hono.js Integration", "item": "https://flashq.dev/blog/elysia-hono-integration.html" }
    ]
  }
  </script>
  <!-- Highlight.js -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
</head>
<body>
  <nav>
    <div class="container wide">
      <a href="../" class="logo"><span>âš¡</span> flashQ</a>
      <div class="nav-links">
        <a href="../#features">Features</a>
        <a href="../blog/" class="active">Blog</a>
        <a href="../docs/">Docs</a>
        <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
        <button class="search-trigger" onclick="openSearch()">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>
          Search <span class="kbd">âŒ˜K</span>
        </button>
        <a href="../docs/#quickstart" class="btn btn-primary">Get Started</a>
      </div>
      <button class="mobile-menu-btn" aria-label="Menu"><span></span><span></span><span></span></button>
    </div>
  </nav>

  <div class="mobile-menu">
    <a href="../#features">Features</a>
    <a href="../blog/">Blog</a>
    <a href="../docs/">Docs</a>
    <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
    <a href="../docs/#quickstart" class="btn btn-primary">Get Started</a>
  </div>

  <header class="article-header header-tutorial">
    <div class="container">
      <span class="article-tag tutorial">Tutorial</span>
      <h1>flashQ + Elysia & Hono.js: Modern Bun-Powered Background Jobs</h1>
      <div class="article-meta">
        <span>ğŸ“… January 19, 2026</span>
        <span class="reading-time">â±ï¸ 12 min read</span>
      </div>
    </div>
  </header>

  <article class="article-content">
    <div class="container wide">
      <div class="article-layout">
        <div class="article-main">

      <p>Elysia and Hono.js are two of the fastest and most developer-friendly web frameworks in the TypeScript ecosystem. When combined with flashQ's high-performance job queue, you get a stack that can handle millions of background jobs while maintaining sub-millisecond API response times.</p>

      <p>In this comprehensive guide, we'll build production-ready background job systems with both frameworks, showing you patterns that scale from prototype to millions of users.</p>

      <h2 id="why">Why Elysia & Hono.js with flashQ?</h2>

      <p>Both frameworks share a philosophy of performance and developer experience:</p>

      <table>
        <thead>
          <tr>
            <th>Feature</th>
            <th>Elysia</th>
            <th>Hono.js</th>
            <th>flashQ</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Runtime</td>
            <td>Bun-native</td>
            <td>Multi-runtime</td>
            <td>Rust-powered</td>
          </tr>
          <tr>
            <td>Performance</td>
            <td>~2.5M req/sec</td>
            <td>~1.5M req/sec</td>
            <td>~1.9M jobs/sec</td>
          </tr>
          <tr>
            <td>Type Safety</td>
            <td>End-to-end</td>
            <td>Full TypeScript</td>
            <td>Typed SDK</td>
          </tr>
          <tr>
            <td>DX</td>
            <td>Excellent</td>
            <td>Excellent</td>
            <td>BullMQ-compatible</td>
          </tr>
        </tbody>
      </table>

      <p>Together, they form a stack where your API responds instantly while heavy work happens asynchronously in the background.</p>

      <h2 id="architecture">Architecture Overview</h2>

      <pre><code class="language-bash">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Elysia/Hono    â”‚     â”‚    flashQ       â”‚     â”‚    Worker       â”‚
â”‚     API         â”‚â”€â”€â”€â”€â–¶â”‚    Server       â”‚â—€â”€â”€â”€â”€â”‚    Process      â”‚
â”‚                 â”‚     â”‚                 â”‚     â”‚                 â”‚
â”‚  - Routes       â”‚     â”‚  - Job Queue    â”‚     â”‚  - AI Tasks     â”‚
â”‚  - Validation   â”‚     â”‚  - Persistence  â”‚     â”‚  - Emails       â”‚
â”‚  - Auth         â”‚     â”‚  - Scheduling   â”‚     â”‚  - Processing   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                                               â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    Same Bun process (optional)</code></pre>

      <p>The beauty of Bun is that you can run both your API and workers in the same process for simplicity, or separate them for scale.</p>

      <h2 id="elysia-setup">Elysia Integration</h2>

      <h3>Project Setup</h3>

      <pre><code class="language-bash"># Create new Elysia project
bun create elysia flashq-elysia
cd flashq-elysia

# Install flashQ
bun add flashq</code></pre>

      <h3>Queue Configuration</h3>

      <pre><code class="language-typescript">// src/queue.ts
import { FlashQ, Worker } from 'flashq';

// Singleton client instance
let client: FlashQ | null = null;

export async function getClient(): Promise&lt;FlashQ&gt; {
  if (!client) {
    client = new FlashQ({
      host: process.env.FLASHQ_HOST || 'localhost',
      port: parseInt(process.env.FLASHQ_PORT || '6789'),
      token: process.env.FLASHQ_TOKEN,
    });
    await client.connect();
  }
  return client;
}

// Queue names as constants for type safety
export const QUEUES = {
  EMAIL: 'email',
  AI_PROCESSING: 'ai-processing',
  WEBHOOKS: 'webhooks',
  NOTIFICATIONS: 'notifications',
} as const;

// Type-safe job data interfaces
export interface EmailJob {
  to: string;
  subject: string;
  template: string;
  data: Record&lt;string, any&gt;;
}

export interface AIJob {
  prompt: string;
  model: 'gpt-4' | 'gpt-4-turbo' | 'claude-3';
  userId: string;
  maxTokens?: number;
}</code></pre>

      <h3>Elysia Plugin for flashQ</h3>

      <pre><code class="language-typescript">// src/plugins/flashq.ts
import { Elysia } from 'elysia';
import { getClient, QUEUES } from '../queue';

export const flashqPlugin = new Elysia({ name: 'flashq' })
  .decorate('queue', {
    // Push a job to any queue
    async push&lt;T&gt;(queue: string, data: T, options?: any) {
      const client = await getClient();
      return client.push(queue, data, options);
    },

    // Get job status
    async getJob(jobId: string) {
      const client = await getClient();
      return client.getJob(jobId);
    },

    // Get job result (for finished() pattern)
    async waitForResult(jobId: string, timeout = 30000) {
      const client = await getClient();
      return client.finished(jobId, timeout);
    },

    // Queue stats
    async stats() {
      const client = await getClient();
      return client.stats();
    },

    QUEUES,
  });</code></pre>

      <h3>API Routes with Elysia</h3>

      <pre><code class="language-typescript">// src/index.ts
import { Elysia, t } from 'elysia';
import { flashqPlugin } from './plugins/flashq';

const app = new Elysia()
  .use(flashqPlugin)

  // Health check with queue stats
  .get('/health', async ({ queue }) => {
    const stats = await queue.stats();
    return {
      status: 'healthy',
      queue: stats,
      timestamp: new Date().toISOString(),
    };
  })

  // Send email endpoint
  .post('/api/email', async ({ body, queue }) => {
    const job = await queue.push(queue.QUEUES.EMAIL, body, {
      attempts: 5,
      backoff: 5000,
    });

    return {
      success: true,
      jobId: job.id,
      message: 'Email queued for delivery',
    };
  }, {
    body: t.Object({
      to: t.String({ format: 'email' }),
      subject: t.String({ minLength: 1 }),
      template: t.String(),
      data: t.Record(t.String(), t.Any()),
    }),
  })

  // AI generation with sync response option
  .post('/api/generate', async ({ body, query, queue }) => {
    const job = await queue.push(queue.QUEUES.AI_PROCESSING, {
      prompt: body.prompt,
      model: body.model || 'gpt-4-turbo',
      userId: body.userId,
      maxTokens: body.maxTokens,
    }, {
      priority: body.priority || 5,
      timeout: 120000, // 2 min for AI
    });

    // Optional: wait for result (sync mode)
    if (query.sync === 'true') {
      const result = await queue.waitForResult(job.id, 60000);
      return { success: true, result };
    }

    return {
      success: true,
      jobId: job.id,
      statusUrl: `/api/jobs/${job.id}`,
    };
  }, {
    body: t.Object({
      prompt: t.String({ minLength: 1 }),
      model: t.Optional(t.Union([
        t.Literal('gpt-4'),
        t.Literal('gpt-4-turbo'),
        t.Literal('claude-3'),
      ])),
      userId: t.String(),
      maxTokens: t.Optional(t.Number({ minimum: 1, maximum: 4096 })),
      priority: t.Optional(t.Number({ minimum: 1, maximum: 100 })),
    }),
    query: t.Object({
      sync: t.Optional(t.String()),
    }),
  })

  // Get job status
  .get('/api/jobs/:id', async ({ params, queue }) => {
    const job = await queue.getJob(params.id);
    if (!job) {
      return { error: 'Job not found' };
    }
    return job;
  })

  // Batch job creation
  .post('/api/batch/emails', async ({ body, queue }) => {
    const client = await getClient();
    const jobs = await client.pushBatch(
      queue.QUEUES.EMAIL,
      body.emails.map((email: any) => ({
        data: email,
        options: { attempts: 3 },
      }))
    );

    return {
      success: true,
      count: jobs.length,
      jobIds: jobs.map(j => j.id),
    };
  }, {
    body: t.Object({
      emails: t.Array(t.Object({
        to: t.String({ format: 'email' }),
        subject: t.String(),
        template: t.String(),
        data: t.Record(t.String(), t.Any()),
      })),
    }),
  })

  .listen(3000);

console.log(`ğŸ¦Š Elysia running at ${app.server?.hostname}:${app.server?.port}`);</code></pre>

      <div class="callout callout-info">
        <div class="callout-title">ğŸ’¡ Type Safety with Elysia</div>
        <p>Elysia's schema validation using <code>t</code> provides end-to-end type safety. Your TypeScript types are automatically inferred from your schema definitions.</p>
      </div>

      <h2 id="hono-setup">Hono.js Integration</h2>

      <h3>Project Setup</h3>

      <pre><code class="language-bash"># Create new Hono project
bun create hono@latest flashq-hono
cd flashq-hono

# Install flashQ and Zod for validation
bun add flashq zod @hono/zod-validator</code></pre>

      <h3>Queue Middleware for Hono</h3>

      <pre><code class="language-typescript">// src/middleware/queue.ts
import { createMiddleware } from 'hono/factory';
import { FlashQ } from 'flashq';

let client: FlashQ | null = null;

async function getClient(): Promise&lt;FlashQ&gt; {
  if (!client) {
    client = new FlashQ({
      host: process.env.FLASHQ_HOST || 'localhost',
      port: parseInt(process.env.FLASHQ_PORT || '6789'),
      token: process.env.FLASHQ_TOKEN,
    });
    await client.connect();
  }
  return client;
}

export const QUEUES = {
  EMAIL: 'email',
  AI: 'ai-processing',
  WEBHOOKS: 'webhooks',
} as const;

type QueueName = typeof QUEUES[keyof typeof QUEUES];

export type QueueVariables = {
  queue: {
    push: &lt;T&gt;(name: QueueName, data: T, options?: any) => Promise&lt;any&gt;;
    getJob: (id: string) => Promise&lt;any&gt;;
    finished: (id: string, timeout?: number) => Promise&lt;any&gt;;
    stats: () => Promise&lt;any&gt;;
  };
};

export const queueMiddleware = createMiddleware&lt;{ Variables: QueueVariables }&gt;(
  async (c, next) => {
    const flashq = await getClient();

    c.set('queue', {
      push: (name, data, options) => flashq.push(name, data, options),
      getJob: (id) => flashq.getJob(id),
      finished: (id, timeout) => flashq.finished(id, timeout),
      stats: () => flashq.stats(),
    });

    await next();
  }
);</code></pre>

      <h3>Hono Routes</h3>

      <pre><code class="language-typescript">// src/index.ts
import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { logger } from 'hono/logger';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';
import { queueMiddleware, QUEUES, type QueueVariables } from './middleware/queue';

const app = new Hono&lt;{ Variables: QueueVariables }&gt;();

// Global middleware
app.use('*', cors());
app.use('*', logger());
app.use('/api/*', queueMiddleware);

// Schemas
const emailSchema = z.object({
  to: z.string().email(),
  subject: z.string().min(1),
  template: z.string(),
  data: z.record(z.any()),
});

const generateSchema = z.object({
  prompt: z.string().min(1),
  model: z.enum(['gpt-4', 'gpt-4-turbo', 'claude-3']).default('gpt-4-turbo'),
  userId: z.string(),
  maxTokens: z.number().min(1).max(4096).optional(),
  priority: z.number().min(1).max(100).default(5),
});

// Health endpoint
app.get('/health', async (c) => {
  const queue = c.get('queue');
  const stats = queue ? await queue.stats() : null;
  return c.json({
    status: 'healthy',
    queue: stats,
    timestamp: new Date().toISOString(),
  });
});

// Email endpoint
app.post(
  '/api/email',
  zValidator('json', emailSchema),
  async (c) => {
    const body = c.req.valid('json');
    const queue = c.get('queue');

    const job = await queue.push(QUEUES.EMAIL, body, {
      attempts: 5,
      backoff: 5000,
    });

    return c.json({
      success: true,
      jobId: job.id,
      message: 'Email queued',
    });
  }
);

// AI Generation endpoint
app.post(
  '/api/generate',
  zValidator('json', generateSchema),
  async (c) => {
    const body = c.req.valid('json');
    const queue = c.get('queue');
    const sync = c.req.query('sync') === 'true';

    const job = await queue.push(QUEUES.AI, body, {
      priority: body.priority,
      timeout: 120000,
    });

    // Sync mode: wait for result
    if (sync) {
      const result = await queue.finished(job.id, 60000);
      return c.json({ success: true, result });
    }

    return c.json({
      success: true,
      jobId: job.id,
      statusUrl: `/api/jobs/${job.id}`,
    });
  }
);

// Job status endpoint
app.get('/api/jobs/:id', async (c) => {
  const queue = c.get('queue');
  const job = await queue.getJob(c.req.param('id'));

  if (!job) {
    return c.json({ error: 'Job not found' }, 404);
  }

  return c.json(job);
});

// Webhook handler with idempotency
app.post('/api/webhooks/:provider', async (c) => {
  const provider = c.req.param('provider');
  const body = await c.req.json();
  const queue = c.get('queue');

  // Use webhook ID for idempotency
  const webhookId = body.id || c.req.header('x-webhook-id');

  const job = await queue.push(QUEUES.WEBHOOKS, {
    provider,
    payload: body,
  }, {
    jobId: `webhook-${provider}-${webhookId}`, // Idempotent
    attempts: 3,
  });

  return c.json({ received: true, jobId: job.id });
});

export default {
  port: 3000,
  fetch: app.fetch,
};</code></pre>

      <h2 id="workers">Worker Implementation</h2>

      <p>The worker can be the same for both Elysia and Hono since it uses the flashQ SDK directly.</p>

      <pre><code class="language-typescript">// worker/index.ts
import { Worker, FlashQ } from 'flashq';
import OpenAI from 'openai';
import { Resend } from 'resend';

const openai = new OpenAI();
const resend = new Resend(process.env.RESEND_API_KEY);

// Email Worker
const emailWorker = new Worker('email', async (job) => {
  const { to, subject, template, data } = job.data;

  // Render template (use your preferred engine)
  const html = renderTemplate(template, data);

  const result = await resend.emails.send({
    from: 'noreply@yourdomain.com',
    to,
    subject,
    html,
  });

  return { emailId: result.id, sentAt: new Date().toISOString() };
}, {
  connection: {
    host: process.env.FLASHQ_HOST || 'localhost',
    port: parseInt(process.env.FLASHQ_PORT || '6789'),
  },
  concurrency: 10,
});

// AI Worker
const aiWorker = new Worker('ai-processing', async (job) => {
  const { prompt, model, maxTokens, userId } = job.data;

  await job.updateProgress(10, 'Connecting to AI...');

  let response;

  if (model.startsWith('gpt')) {
    response = await openai.chat.completions.create({
      model,
      messages: [{ role: 'user', content: prompt }],
      max_tokens: maxTokens || 1000,
    });

    await job.updateProgress(90, 'Processing complete');

    return {
      content: response.choices[0].message.content,
      model,
      tokens: response.usage?.total_tokens,
      userId,
    };
  }

  // Claude handling would go here
  throw new Error(`Unsupported model: ${model}`);
}, {
  connection: {
    host: process.env.FLASHQ_HOST || 'localhost',
    port: parseInt(process.env.FLASHQ_PORT || '6789'),
  },
  concurrency: 3, // Limit AI concurrency
});

// Webhook Worker
const webhookWorker = new Worker('webhooks', async (job) => {
  const { provider, payload } = job.data;

  switch (provider) {
    case 'stripe':
      return await handleStripeWebhook(payload);
    case 'github':
      return await handleGithubWebhook(payload);
    default:
      throw new Error(`Unknown provider: ${provider}`);
  }
}, {
  connection: {
    host: process.env.FLASHQ_HOST || 'localhost',
    port: parseInt(process.env.FLASHQ_PORT || '6789'),
  },
  concurrency: 20,
});

// Event handlers
[emailWorker, aiWorker, webhookWorker].forEach(worker => {
  worker.on('completed', (job, result) => {
    console.log(`âœ“ [${worker.name}] Job ${job.id} completed`);
  });

  worker.on('failed', (job, error) => {
    console.error(`âœ— [${worker.name}] Job ${job.id} failed: ${error.message}`);
  });
});

console.log('ğŸ”§ Workers started: email, ai-processing, webhooks');</code></pre>

      <h2 id="advanced">Advanced Patterns</h2>

      <h3>Rate Limiting per User</h3>

      <pre><code class="language-typescript">// Elysia example with per-user rate limiting
.post('/api/generate', async ({ body, queue }) => {
  const client = await getClient();

  // Check user's current job count
  const userQueueName = `ai-${body.userId}`;
  const counts = await client.getJobCounts(userQueueName);

  if (counts.active + counts.waiting > 5) {
    return {
      error: 'Rate limit exceeded',
      message: 'Maximum 5 pending jobs allowed',
    };
  }

  // Use user-specific queue with rate limiting
  await client.setRateLimit(userQueueName, {
    max: 10,        // 10 jobs
    duration: 60000, // per minute
  });

  const job = await client.push(userQueueName, body);
  return { success: true, jobId: job.id };
})</code></pre>

      <h3>Job Workflows with Dependencies</h3>

      <pre><code class="language-typescript">// Hono example: Multi-step AI pipeline
app.post('/api/pipeline', async (c) => {
  const queue = c.get('queue');
  const body = await c.req.json();
  const client = await getClient();

  // Step 1: Extract text from document
  const extractJob = await client.push('extract', {
    documentUrl: body.documentUrl,
  });

  // Step 2: Summarize (depends on extraction)
  const summarizeJob = await client.push('summarize', {
    sourceJobId: extractJob.id,
  }, {
    depends_on: [extractJob.id],
  });

  // Step 3: Generate embeddings (depends on extraction)
  const embedJob = await client.push('embed', {
    sourceJobId: extractJob.id,
  }, {
    depends_on: [extractJob.id],
  });

  // Step 4: Store in vector DB (depends on embeddings)
  const storeJob = await client.push('store-vectors', {
    sourceJobId: embedJob.id,
  }, {
    depends_on: [embedJob.id],
  });

  return c.json({
    pipelineId: extractJob.id,
    jobs: {
      extract: extractJob.id,
      summarize: summarizeJob.id,
      embed: embedJob.id,
      store: storeJob.id,
    },
  });
});</code></pre>

      <h3>Real-time Progress with SSE</h3>

      <pre><code class="language-typescript">// Elysia SSE for job progress
import { Elysia } from 'elysia';

new Elysia()
  .get('/api/jobs/:id/stream', async function* ({ params }) {
    const client = await getClient();
    let lastState = '';
    let lastProgress = -1;

    while (true) {
      const job = await client.getJob(params.id);
      if (!job) {
        yield { event: 'error', data: 'Job not found' };
        break;
      }

      const state = await client.getState(params.id);
      const progress = await client.getProgress(params.id);

      // Only emit on changes
      if (state !== lastState || progress?.percent !== lastProgress) {
        yield {
          event: 'update',
          data: JSON.stringify({ state, progress }),
        };
        lastState = state;
        lastProgress = progress?.percent || 0;
      }

      if (state === 'completed' || state === 'failed') {
        const result = await client.getResult(params.id);
        yield {
          event: state,
          data: JSON.stringify({ result }),
        };
        break;
      }

      await Bun.sleep(500);
    }
  });</code></pre>

      <div class="callout callout-success">
        <div class="callout-title">ğŸš€ Performance Tip</div>
        <p>For high-throughput scenarios, use flashQ's binary protocol (MessagePack) by setting <code>useBinary: true</code> in the client options. This reduces payload size by 40% and speeds up serialization by 3-5x.</p>
      </div>

      <h2 id="deployment">Deployment</h2>

      <h3>Docker Compose Setup</h3>

      <pre><code class="language-bash"># docker-compose.yml
version: '3.8'

services:
  flashq:
    image: ghcr.io/egeominotti/flashq:latest
    ports:
      - "6789:6789"
      - "6790:6790"
    environment:
      - DATABASE_URL=postgres://flashq:flashq@postgres:5432/flashq
      - HTTP=1
      - AUTH_TOKENS=your-secret-token
    depends_on:
      - postgres

  postgres:
    image: postgres:16-alpine
    environment:
      - POSTGRES_USER=flashq
      - POSTGRES_PASSWORD=flashq
      - POSTGRES_DB=flashq
    volumes:
      - postgres_data:/var/lib/postgresql/data

  api:
    build: .
    ports:
      - "3000:3000"
    environment:
      - FLASHQ_HOST=flashq
      - FLASHQ_PORT=6789
      - FLASHQ_TOKEN=your-secret-token
    depends_on:
      - flashq

  worker:
    build:
      context: .
      dockerfile: Dockerfile.worker
    environment:
      - FLASHQ_HOST=flashq
      - FLASHQ_PORT=6789
      - FLASHQ_TOKEN=your-secret-token
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - RESEND_API_KEY=${RESEND_API_KEY}
    depends_on:
      - flashq
    deploy:
      replicas: 3

volumes:
  postgres_data:</code></pre>

      <h3>Dockerfile for Bun</h3>

      <pre><code class="language-bash"># Dockerfile
FROM oven/bun:1 AS base
WORKDIR /app

# Install dependencies
FROM base AS deps
COPY package.json bun.lockb ./
RUN bun install --frozen-lockfile

# Build
FROM base AS build
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN bun build ./src/index.ts --outdir ./dist --target bun

# Production
FROM base AS production
COPY --from=build /app/dist ./dist
COPY --from=deps /app/node_modules ./node_modules
EXPOSE 3000
CMD ["bun", "run", "dist/index.js"]</code></pre>

      <h2 id="conclusion">Conclusion</h2>

      <p>Elysia and Hono.js combined with flashQ create an exceptionally fast stack for building modern APIs with background job processing:</p>

      <ul>
        <li><strong>Elysia</strong>: Best for Bun-native applications with end-to-end type safety</li>
        <li><strong>Hono.js</strong>: Perfect for multi-runtime support (Bun, Node, Cloudflare Workers)</li>
        <li><strong>flashQ</strong>: Handles your background jobs with 1.9M jobs/sec throughput</li>
      </ul>

      <p>Both frameworks integrate seamlessly with flashQ's TypeScript SDK, giving you type-safe job queues with minimal configuration.</p>

      <div class="article-cta">
        <h3>Start Building Today</h3>
        <p>Get started with flashQ and your favorite Bun framework.</p>
        <a href="../docs/#quickstart" class="btn btn-primary">Get Started â†’</a>
      </div>
        </div>

        <aside class="toc-sidebar">
          <nav class="toc">
            <div class="toc-title">On this page</div>
            <ul class="toc-list">
              <li><a href="#why">Why Elysia & Hono.js</a></li>
              <li><a href="#architecture">Architecture</a></li>
              <li><a href="#elysia-setup">Elysia Integration</a></li>
              <li><a href="#hono-setup">Hono.js Integration</a></li>
              <li><a href="#workers">Worker Implementation</a></li>
              <li><a href="#advanced">Advanced Patterns</a></li>
              <li><a href="#deployment">Deployment</a></li>
              <li><a href="#conclusion">Conclusion</a></li>
            </ul>
          </nav>
        </aside>
      </div>
    </div>
  </article>

  <footer>
    <div class="container wide">
      <a href="../" class="logo"><span>âš¡</span> flashQ</a>
      <div class="footer-links">
        <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
        <a href="https://npmjs.com/package/flashq" target="_blank">npm</a>
        <a href="../docs/">Docs</a>
        <a href="../blog/">Blog</a>
      </div>
      <div class="footer-copy">Â© <span id="year"></span> flashQ. MIT License.</div>
    </div>
  </footer>

  <div class="search-overlay" id="searchOverlay" onclick="closeSearch(event)">
    <div class="search-modal" onclick="event.stopPropagation()">
      <div class="search-input-wrapper">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>
        <input type="text" class="search-modal-input" id="searchInput" placeholder="Search articles and docs...">
        <span class="search-shortcut">ESC</span>
      </div>
      <div class="search-results" id="searchResults"></div>
    </div>
  </div>

  <script>
    document.getElementById("year").textContent = new Date().getFullYear();
    const mobileMenuBtn = document.querySelector(".mobile-menu-btn");
    const mobileMenu = document.querySelector(".mobile-menu");
    mobileMenuBtn.addEventListener("click", () => { mobileMenuBtn.classList.toggle("active"); mobileMenu.classList.toggle("active"); document.body.style.overflow = mobileMenu.classList.contains("active") ? "hidden" : ""; });
    const tocLinks = document.querySelectorAll('.toc-list a');
    const headings = document.querySelectorAll('h2[id]');
    function updateTocActive() { let current = ''; headings.forEach(h => { if (window.scrollY >= h.offsetTop - 120) current = h.id; }); tocLinks.forEach(l => l.classList.toggle('active', l.getAttribute('href') === '#' + current)); }
    window.addEventListener('scroll', updateTocActive); updateTocActive();
    const searchData = [{ title: "Elysia & Hono.js Integration", url: "elysia-hono-integration.html", description: "Modern Bun-powered background jobs", tag: "Tutorial" }, { title: "Documentation", url: "../docs/", description: "API reference", tag: "Docs" }];
    let selectedIndex = 0;
    function openSearch() { document.getElementById('searchOverlay').classList.add('active'); document.getElementById('searchInput').focus(); renderResults(''); }
    function closeSearch(e) { if (e?.target !== document.getElementById('searchOverlay')) return; document.getElementById('searchOverlay').classList.remove('active'); }
    function renderResults(q) { const r = q ? searchData.filter(i => i.title.toLowerCase().includes(q.toLowerCase())) : searchData; document.getElementById('searchResults').innerHTML = r.map((i,idx) => `<a href="${i.url}" class="search-result ${idx===0?'active':''}"><div class="search-result-title">${i.title}</div><div class="search-result-description">${i.description}</div></a>`).join('') || '<div class="search-empty">No results</div>'; }
    document.getElementById('searchInput').addEventListener('input', e => renderResults(e.target.value));
    document.addEventListener('keydown', e => { if ((e.metaKey||e.ctrlKey) && e.key==='k') { e.preventDefault(); openSearch(); } if (e.key==='Escape') closeSearch({target:document.getElementById('searchOverlay')}); });
  </script>
  <script>hljs.highlightAll();</script>
</body>
</html>
