<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>flashQ Security Best Practices - flashQ Blog</title>
  <meta name="description" content="Comprehensive security guide for flashQ deployments. Learn authentication, encryption, input validation, network security, and compliance best practices.">
  <meta name="keywords" content="flashq security, job queue security, authentication tokens, encryption, input validation, rate limiting, network security, compliance">
  <meta name="robots" content="index, follow">
  <meta name="author" content="flashQ Team">

  <meta property="og:title" content="flashQ Security Best Practices">
  <meta property="og:description" content="Comprehensive security guide for production flashQ deployments.">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://flashq.dev/blog/security-best-practices.html">
  <meta property="og:image" content="https://flashq.dev/og-image.png">
  <meta property="og:site_name" content="flashQ">
  <meta property="article:published_time" content="2026-01-19">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="flashQ Security Best Practices">
  <meta name="twitter:description" content="Comprehensive security guide for flashQ deployments.">
  <meta name="twitter:image" content="https://flashq.dev/og-image.png">

  <link rel="canonical" href="https://flashq.dev/blog/security-best-practices.html">
  <link rel="alternate" type="application/rss+xml" title="flashQ Blog RSS Feed" href="https://flashq.dev/blog/feed.xml">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚ö°</text></svg>">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "TechArticle",
    "headline": "flashQ Security Best Practices",
    "description": "Comprehensive security guide for production flashQ deployments.",
    "datePublished": "2026-01-19",
    "author": { "@type": "Organization", "name": "flashQ" },
    "publisher": { "@type": "Organization", "name": "flashQ", "logo": { "@type": "ImageObject", "url": "https://flashq.dev/logo.png" } }
  }
  </script>

  <!-- Breadcrumb Schema -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
      { "@type": "ListItem", "position": 1, "name": "Home", "item": "https://flashq.dev" },
      { "@type": "ListItem", "position": 2, "name": "Blog", "item": "https://flashq.dev/blog/" },
      { "@type": "ListItem", "position": 3, "name": "Security Best Practices", "item": "https://flashq.dev/blog/security-best-practices.html" }
    ]
  }
  </script>
  <!-- Highlight.js -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
</head>
<body>
  <nav>
    <div class="container wide">
      <a href="../" class="logo"><span>‚ö°</span> flashQ</a>
      <div class="nav-links">
        <a href="../#features">Features</a>
        <a href="../blog/" class="active">Blog</a>
        <a href="../docs/">Docs</a>
        <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
        <button class="search-trigger" onclick="openSearch()"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>Search <span class="kbd">‚åòK</span></button>
        <a href="../docs/#quickstart" class="btn btn-primary">Get Started</a>
      </div>
      <button class="mobile-menu-btn" aria-label="Menu"><span></span><span></span><span></span></button>
    </div>
  </nav>

  <div class="mobile-menu">
    <a href="../#features">Features</a><a href="../blog/">Blog</a><a href="../docs/">Docs</a>
    <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
    <a href="../docs/#quickstart" class="btn btn-primary">Get Started</a>
  </div>

  <header class="article-header header-security">
    <div class="container">
      <span class="article-tag">Security</span>
      <h1>flashQ Security Best Practices</h1>
      <div class="article-meta">
        <span>üìÖ January 19, 2026</span>
        <span class="reading-time">‚è±Ô∏è 15 min read</span>
      </div>
    </div>
  </header>

  <article class="article-content">
    <div class="container wide">
      <div class="article-layout">
        <div class="article-main">

      <p>Security is critical for any job queue system handling sensitive data. This guide covers authentication, encryption, input validation, network security, and compliance best practices for flashQ deployments.</p>

      <div class="callout callout-warning">
        <div class="callout-title">Security First</div>
        <p>Never deploy flashQ to production without enabling authentication and reviewing these security practices. An unsecured queue can expose sensitive data and allow arbitrary code execution.</p>
      </div>

      <h2 id="authentication">Authentication</h2>

      <h3>Token-Based Authentication</h3>

      <p>flashQ uses bearer token authentication. Configure tokens via environment variables.</p>

      <pre><code class="language-bash"># Server configuration
AUTH_TOKENS=token1,token2,token3

# Or a single secure token
AUTH_TOKENS=$(openssl rand -hex 32)</code></pre>

      <pre><code class="language-typescript">// Client authentication
import { FlashQ } from 'flashq';

const client = new FlashQ({
  host: 'flashq.internal',
  port: 6789,
  token: process.env.FLASHQ_TOKEN // Never hardcode!
});

await client.connect();</code></pre>

      <h3>Token Rotation</h3>

      <pre><code class="language-typescript">// Implement token rotation without downtime
// 1. Add new token while keeping old ones
AUTH_TOKENS=old_token,new_token

// 2. Update all clients to use new token
const client = new FlashQ({
  token: process.env.FLASHQ_TOKEN_NEW
});

// 3. After all clients updated, remove old token
AUTH_TOKENS=new_token</code></pre>

      <h3>Per-Queue Authorization</h3>

      <pre><code class="language-typescript">// Implement role-based queue access
interface TokenPermissions {
  token: string;
  queues: string[];        // Allowed queue patterns
  operations: string[];    // push, pull, admin, etc.
}

const permissions: TokenPermissions[] = [
  {
    token: 'worker-token-xxx',
    queues: ['jobs:*', 'tasks:*'],
    operations: ['pull', 'ack', 'fail', 'progress']
  },
  {
    token: 'producer-token-xxx',
    queues: ['jobs:*'],
    operations: ['push', 'getJob', 'cancel']
  },
  {
    token: 'admin-token-xxx',
    queues: ['*'],
    operations: ['*']
  }
];

// Middleware to check permissions
function checkPermission(token: string, queue: string, op: string): boolean {
  const perm = permissions.find(p => p.token === token);
  if (!perm) return false;

  const queueAllowed = perm.queues.some(pattern =>
    matchPattern(pattern, queue)
  );
  const opAllowed = perm.operations.includes('*') ||
                    perm.operations.includes(op);

  return queueAllowed && opAllowed;
}</code></pre>

      <h2 id="encryption">Encryption</h2>

      <h3>TLS/SSL for Transport</h3>

      <pre><code class="language-bash"># Enable TLS with nginx reverse proxy
# nginx.conf
server {
    listen 443 ssl;
    server_name flashq.example.com;

    ssl_certificate /etc/ssl/flashq.crt;
    ssl_certificate_key /etc/ssl/flashq.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;

    location / {
        proxy_pass http://flashq:6790;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}

# TCP passthrough for binary protocol
stream {
    server {
        listen 6789 ssl;
        proxy_pass flashq:6789;
        ssl_certificate /etc/ssl/flashq.crt;
        ssl_certificate_key /etc/ssl/flashq.key;
    }
}</code></pre>

      <h3>Encrypting Job Data</h3>

      <pre><code class="language-typescript">// encryption/job-encryption.ts
import { createCipheriv, createDecipheriv, randomBytes } from 'crypto';

const ALGORITHM = 'aes-256-gcm';
const KEY = Buffer.from(process.env.ENCRYPTION_KEY!, 'hex'); // 32 bytes

interface EncryptedData {
  iv: string;
  tag: string;
  data: string;
}

function encryptJobData(data: any): EncryptedData {
  const iv = randomBytes(16);
  const cipher = createCipheriv(ALGORITHM, KEY, iv);

  const plaintext = JSON.stringify(data);
  let encrypted = cipher.update(plaintext, 'utf8', 'base64');
  encrypted += cipher.final('base64');

  return {
    iv: iv.toString('base64'),
    tag: cipher.getAuthTag().toString('base64'),
    data: encrypted
  };
}

function decryptJobData(encrypted: EncryptedData): any {
  const iv = Buffer.from(encrypted.iv, 'base64');
  const tag = Buffer.from(encrypted.tag, 'base64');
  const decipher = createDecipheriv(ALGORITHM, KEY, iv);
  decipher.setAuthTag(tag);

  let decrypted = decipher.update(encrypted.data, 'base64', 'utf8');
  decrypted += decipher.final('utf8');

  return JSON.parse(decrypted);
}

// Usage with flashQ
async function pushEncryptedJob(queue: string, data: any) {
  const encrypted = encryptJobData(data);
  return flashq.push(queue, { encrypted });
}

// Worker decryption
const worker = new Worker(flashq, 'secure-jobs', async (job) => {
  const data = decryptJobData(job.data.encrypted);
  // Process decrypted data
  return processJob(data);
});</code></pre>

      <h3>Field-Level Encryption</h3>

      <pre><code class="language-typescript">// Encrypt only sensitive fields
const SENSITIVE_FIELDS = ['ssn', 'creditCard', 'password', 'apiKey'];

function encryptSensitiveFields(data: Record&lt;string, any&gt;): Record&lt;string, any&gt; {
  const result = { ...data };

  for (const field of SENSITIVE_FIELDS) {
    if (field in result) {
      result[`_encrypted_${field}`] = encryptJobData(result[field]);
      delete result[field];
    }
  }

  return result;
}

function decryptSensitiveFields(data: Record&lt;string, any&gt;): Record&lt;string, any&gt; {
  const result = { ...data };

  for (const key of Object.keys(result)) {
    if (key.startsWith('_encrypted_')) {
      const field = key.replace('_encrypted_', '');
      result[field] = decryptJobData(result[key]);
      delete result[key];
    }
  }

  return result;
}</code></pre>

      <h2 id="input-validation">Input Validation</h2>

      <h3>Schema Validation with Zod</h3>

      <pre><code class="language-typescript">// validation/job-schemas.ts
import { z } from 'zod';

// Define strict schemas for each job type
const EmailJobSchema = z.object({
  to: z.string().email().max(254),
  subject: z.string().max(998), // RFC 5322 limit
  body: z.string().max(1048576), // 1MB max
  attachments: z.array(z.object({
    filename: z.string().max(255).regex(/^[a-zA-Z0-9._-]+$/),
    contentType: z.string().max(100),
    size: z.number().max(10485760) // 10MB max
  })).max(10).optional()
});

const PaymentJobSchema = z.object({
  orderId: z.string().uuid(),
  amount: z.number().positive().max(999999.99),
  currency: z.enum(['USD', 'EUR', 'GBP']),
  customerId: z.string().uuid()
});

const ImageProcessingSchema = z.object({
  imageUrl: z.string().url().startsWith('https://'),
  operations: z.array(z.enum([
    'resize', 'crop', 'rotate', 'compress'
  ])).max(10),
  outputFormat: z.enum(['jpeg', 'png', 'webp'])
});

// Validate before pushing
async function pushValidatedJob&lt;T&gt;(
  queue: string,
  schema: z.Schema&lt;T&gt;,
  data: unknown
) {
  const validated = schema.parse(data);
  return flashq.push(queue, validated);
}

// Usage
await pushValidatedJob('emails', EmailJobSchema, {
  to: 'user@example.com',
  subject: 'Hello',
  body: 'Content here'
});</code></pre>

      <h3>Sanitization</h3>

      <pre><code class="language-typescript">// validation/sanitize.ts
import DOMPurify from 'isomorphic-dompurify';

// Sanitize HTML content
function sanitizeHtml(html: string): string {
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'p', 'br'],
    ALLOWED_ATTR: []
  });
}

// Remove potential injection characters
function sanitizeString(str: string): string {
  return str
    .replace(/[<>'"&]/g, '') // Remove dangerous chars
    .trim()
    .slice(0, 10000); // Limit length
}

// Sanitize file paths (prevent path traversal)
function sanitizePath(path: string): string {
  return path
    .replace(/\.\./g, '') // Remove parent directory refs
    .replace(/^\//, '')   // Remove leading slash
    .replace(/[^a-zA-Z0-9._/-]/g, ''); // Whitelist chars
}

// Sanitize SQL (for dynamic queries, prefer parameterized)
function sanitizeSqlIdentifier(identifier: string): string {
  if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(identifier)) {
    throw new Error('Invalid SQL identifier');
  }
  return identifier;
}</code></pre>

      <h2 id="rate-limiting">Rate Limiting</h2>

      <h3>Queue-Level Rate Limits</h3>

      <pre><code class="language-typescript">// Set rate limits per queue
await flashq.setRateLimit('api-calls', {
  max: 100,        // 100 jobs
  duration: 60000 // per minute
});

// Different limits for different queues
const rateLimits = {
  'emails': { max: 1000, duration: 3600000 },    // 1000/hour
  'payments': { max: 100, duration: 60000 },       // 100/minute
  'notifications': { max: 10000, duration: 60000 } // 10000/minute
};

for (const [queue, limit] of Object.entries(rateLimits)) {
  await flashq.setRateLimit(queue, limit);
}</code></pre>

      <h3>Client-Level Rate Limiting</h3>

      <pre><code class="language-typescript">// Implement client-side rate limiting
import { RateLimiter } from 'limiter';

class RateLimitedClient {
  private client: FlashQ;
  private limiters: Map&lt;string, RateLimiter&gt; = new Map();

  constructor(client: FlashQ) {
    this.client = client;
  }

  private getLimiter(queue: string): RateLimiter {
    if (!this.limiters.has(queue)) {
      this.limiters.set(queue, new RateLimiter({
        tokensPerInterval: 100,
        interval: 'minute'
      }));
    }
    return this.limiters.get(queue)!;
  }

  async push(queue: string, data: any, options?: any) {
    const limiter = this.getLimiter(queue);

    if (!limiter.tryRemoveTokens(1)) {
      throw new Error(`Rate limit exceeded for queue: ${queue}`);
    }

    return this.client.push(queue, data, options);
  }
}</code></pre>

      <h2 id="network">Network Security</h2>

      <h3>Firewall Configuration</h3>

      <pre><code class="language-bash"># Only allow internal network access to flashQ
# iptables rules
iptables -A INPUT -p tcp --dport 6789 -s 10.0.0.0/8 -j ACCEPT
iptables -A INPUT -p tcp --dport 6789 -j DROP

iptables -A INPUT -p tcp --dport 6790 -s 10.0.0.0/8 -j ACCEPT
iptables -A INPUT -p tcp --dport 6790 -j DROP</code></pre>

      <h3>Kubernetes Network Policy</h3>

      <pre><code class="language-bash"># k8s/network-policy.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: flashq-network-policy
  namespace: flashq
spec:
  podSelector:
    matchLabels:
      app: flashq
  policyTypes:
    - Ingress
    - Egress
  ingress:
    # Only allow from workers namespace
    - from:
        - namespaceSelector:
            matchLabels:
              name: workers
        - podSelector:
            matchLabels:
              role: worker
      ports:
        - port: 6789
        - port: 6790
    # Allow from monitoring
    - from:
        - namespaceSelector:
            matchLabels:
              name: monitoring
      ports:
        - port: 6790 # Metrics only
  egress:
    # Only allow PostgreSQL
    - to:
        - namespaceSelector:
            matchLabels:
              name: databases
      ports:
        - port: 5432</code></pre>

      <h3>Private VPC Deployment</h3>

      <pre><code class="language-bash"># terraform/vpc.tf
resource "aws_vpc" "flashq" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_hostnames = true

  tags = {
    Name = "flashq-vpc"
  }
}

resource "aws_subnet" "private" {
  vpc_id            = aws_vpc.flashq.id
  cidr_block        = "10.0.1.0/24"
  availability_zone = "us-east-1a"

  tags = {
    Name = "flashq-private"
  }
}

# No internet gateway - truly private
resource "aws_security_group" "flashq" {
  vpc_id = aws_vpc.flashq.id

  ingress {
    from_port   = 6789
    to_port     = 6790
    protocol    = "tcp"
    cidr_blocks = ["10.0.0.0/16"]
  }

  egress {
    from_port   = 5432
    to_port     = 5432
    protocol    = "tcp"
    cidr_blocks = ["10.0.2.0/24"] # Database subnet
  }
}</code></pre>

      <h2 id="audit-logging">Audit Logging</h2>

      <pre><code class="language-typescript">// audit/logger.ts
interface AuditLog {
  timestamp: string;
  action: string;
  queue: string;
  jobId?: string;
  userId?: string;
  ip?: string;
  success: boolean;
  details?: Record&lt;string, any&gt;;
}

class AuditLogger {
  private logs: AuditLog[] = [];

  log(entry: Omit&lt;AuditLog, 'timestamp'&gt;) {
    const auditEntry: AuditLog = {
      ...entry,
      timestamp: new Date().toISOString()
    };

    // Log to stdout (for log aggregation)
    console.log(JSON.stringify(auditEntry));

    // Also push to audit queue for persistence
    flashq.push('audit:logs', auditEntry, {
      ttl: 86400000 * 90 // Keep for 90 days
    });
  }
}

const audit = new AuditLogger();

// Wrap flashQ operations with audit logging
class AuditedFlashQ {
  private client: FlashQ;
  private userId: string;
  private ip: string;

  constructor(client: FlashQ, userId: string, ip: string) {
    this.client = client;
    this.userId = userId;
    this.ip = ip;
  }

  async push(queue: string, data: any, options?: any) {
    try {
      const result = await this.client.push(queue, data, options);
      audit.log({
        action: 'push',
        queue,
        jobId: result.id,
        userId: this.userId,
        ip: this.ip,
        success: <span class="literal">true
      });
      return result;
    } catch (error) {
      audit.log({
        action: 'push',
        queue,
        userId: this.userId,
        ip: this.ip,
        success: <span class="literal">false,
        details: { error: error.message }
      });
      throw error;
    }
  }
}</code></pre>

      <h2 id="secrets">Secrets Management</h2>

      <pre><code class="language-typescript">// Never store secrets in code or environment directly
// Use a secrets manager

// AWS Secrets Manager
import { SecretsManager } from '@aws-sdk/client-secrets-manager';

async function getFlashQToken(): Promise&lt;string&gt; {
  const client = new SecretsManager({ region: 'us-east-1' });
  const response = await client.getSecretValue({
    SecretId: 'flashq/production/token'
  });
  return response.SecretString!;
}

// HashiCorp Vault
import Vault from 'node-vault';

async function getSecretsFromVault() {
  const vault = Vault({
    apiVersion: 'v1',
    endpoint: process.env.VAULT_ADDR
  });

  await vault.approleLogin({
    role_id: process.env.VAULT_ROLE_ID,
    secret_id: process.env.VAULT_SECRET_ID
  });

  const secrets = await vault.read('secret/data/flashq');
  return secrets.data.data;
}

// Kubernetes secrets
// Mount as files, not environment variables
const token = readFileSync('/etc/secrets/flashq-token', 'utf8').trim();</code></pre>

      <h2 id="compliance">Compliance Considerations</h2>

      <h3>GDPR / Data Privacy</h3>

      <pre><code class="language-typescript">// Implement data retention policies
async function cleanupUserData(userId: string) {
  // Find all jobs for user
  const queues = await flashq.listQueues();

  for (const queue of queues) {
    const jobs = await flashq.getJobs(queue, 'completed', 10000);

    for (const job of jobs) {
      if (job.data?.userId === userId) {
        // Anonymize or delete
        await flashq.update(job.id, {
          ...job.data,
          email: '[REDACTED]',
          name: '[REDACTED]',
          personalData: <span class="literal">null
        });
      }
    }
  }
}

// Auto-cleanup old completed jobs
await flashq.clean('*', 86400000 * 30, 'completed'); // 30 days</code></pre>

      <h3>PCI-DSS (Payment Data)</h3>

      <pre><code class="language-typescript">// Never store raw card data in jobs
// Only store tokenized references

interface PaymentJob {
  paymentTokenId: string;  // Token from payment processor
  orderId: string;
  amount: number;
  // NO: cardNumber, cvv, expiryDate
}

// Worker fetches actual payment data from secure vault
const worker = new Worker(flashq, 'payments', async (job) => {
  const { paymentTokenId, orderId, amount } = job.data;

  // Retrieve from payment processor
  const result = await stripe.paymentIntents.create({
    payment_method: paymentTokenId,
    amount,
    currency: 'usd',
    confirm: <span class="literal">true
  });

  return { success: <span class="literal">true, transactionId: result.id };
});</code></pre>

      <div class="callout callout-success">
        <div class="callout-title">Security Checklist</div>
        <p>‚úì Enable authentication tokens<br>‚úì Use TLS for all connections<br>‚úì Encrypt sensitive job data<br>‚úì Validate all inputs<br>‚úì Set rate limits<br>‚úì Configure network policies<br>‚úì Enable audit logging<br>‚úì Use secrets manager<br>‚úì Implement data retention</p>
      </div>

      <h2 id="conclusion">Conclusion</h2>

      <p>Security requires a defense-in-depth approach. By implementing authentication, encryption, validation, and monitoring, you can confidently run flashQ in production with sensitive workloads.</p>

      <div class="article-cta">
        <h3>Secure Your Queue</h3>
        <p>Start with our security-first deployment guide.</p>
        <a href="../docs/#quickstart" class="btn btn-primary">Get Started ‚Üí</a>
      </div>
        </div>

        <aside class="toc-sidebar">
          <nav class="toc">
            <div class="toc-title">On this page</div>
            <ul class="toc-list">
              <li><a href="#authentication">Authentication</a></li>
              <li><a href="#encryption">Encryption</a></li>
              <li><a href="#input-validation">Input Validation</a></li>
              <li><a href="#rate-limiting">Rate Limiting</a></li>
              <li><a href="#network">Network Security</a></li>
              <li><a href="#audit-logging">Audit Logging</a></li>
              <li><a href="#secrets">Secrets Management</a></li>
              <li><a href="#compliance">Compliance</a></li>
              <li><a href="#conclusion">Conclusion</a></li>
            </ul>
          </nav>
        </aside>
      </div>
    </div>
  </article>

  <footer>
    <div class="container wide">
      <a href="../" class="logo"><span>‚ö°</span> flashQ</a>
      <div class="footer-links">
        <a href="https://github.com/egeominotti/flashq" target="_blank">GitHub</a>
        <a href="https://npmjs.com/package/flashq" target="_blank">npm</a>
        <a href="../docs/">Docs</a>
        <a href="../blog/">Blog</a>
      </div>
      <div class="footer-copy">¬© <span id="year"></span> flashQ. MIT License.</div>
    </div>
  </footer>

  <div class="search-overlay" id="searchOverlay" onclick="closeSearch(event)">
    <div class="search-modal" onclick="event.stopPropagation()">
      <div class="search-input-wrapper">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>
        <input type="text" class="search-modal-input" id="searchInput" placeholder="Search...">
        <span class="search-shortcut">ESC</span>
      </div>
      <div class="search-results" id="searchResults"></div>
    </div>
  </div>

  <script>
    document.getElementById("year").textContent = new Date().getFullYear();
    const mobileMenuBtn = document.querySelector(".mobile-menu-btn");
    const mobileMenu = document.querySelector(".mobile-menu");
    mobileMenuBtn.addEventListener("click", () => { mobileMenuBtn.classList.toggle("active"); mobileMenu.classList.toggle("active"); });
    const tocLinks = document.querySelectorAll('.toc-list a');
    const headings = document.querySelectorAll('h2[id]');
    function updateTocActive() { let current = ''; headings.forEach(h => { if (window.scrollY >= h.offsetTop - 120) current = h.id; }); tocLinks.forEach(l => l.classList.toggle('active', l.getAttribute('href') === '#' + current)); }
    window.addEventListener('scroll', updateTocActive); updateTocActive();
    function openSearch() { document.getElementById('searchOverlay').classList.add('active'); document.getElementById('searchInput').focus(); }
    function closeSearch(e) { if (e?.target === document.getElementById('searchOverlay')) document.getElementById('searchOverlay').classList.remove('active'); }
    document.addEventListener('keydown', e => { if ((e.metaKey||e.ctrlKey) && e.key==='k') { e.preventDefault(); openSearch(); } if (e.key==='Escape') closeSearch({target:document.getElementById('searchOverlay')}); });
  </script>
  <script>hljs.highlightAll();</script>
</body>
</html>
